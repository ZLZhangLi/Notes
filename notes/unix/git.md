[TOC]

## 设置`Git`
在使用`Git`之前，首先要设置用户的**全局用户名**和**邮箱**，做为代码提交者的身份。

```
$ git config --global user.name [用户名]
$ git config --global user.email [邮箱]
```

设置Git的默认编辑器：

`$ git config --global core.editor [编辑器名称]`

设置Git的远程推送方式：

`$ git config --global push.default [推送选项]`

其中，在`Git 2.0`之后推送选项值默认为`simple`，之前为`matching`。

推送选项取值含义：

- `current`、`simple` 推送当前分支到远程关联的同名分支
- `matching` 推送与远程仓库具有的分支中所有与本地仓库分支同名的本地分支

设置`Git`换行符处理方式：

`$ git config --global core.autocrlf [换行符处理方式]`

换行符选项取值含义：

- `true` Windows提交到Unix环境时使用，提交时将CRLF转换为LF，而签出代码时自动将LF转换为CRLF
- `input` Unix环境中使用，提交时CRLF换行符转换为LF，而签出代码时LF不转换为CRLF
- `false` Windows环境中使用，不转换CRLF，直接提交

### `Git`配置文件
使用`git config`指令会将配置写入**当前仓库**的`.git/config`文件下，只对当前仓库生效。

使用`git config --global`指令会将配置写入**全局配置文件**中，在`Linux/macOS/*BSD`中，全局配置文件是家目录下的`.gitconfig`文件。
全局配置的优先级**低于**当前仓库的配置，当前仓库的配置与全局配置不一致时会**覆盖**全局配置。



## 版本库的常见操作
如同其它版本控制工具一样，使用`Git`能够方便地进行版本的**提交**、**回滚**、**比较**等操作。

### 创建版本库
选择一个可用的空目录作为源码仓库，执行指令将此目录初始化为版本库：

`$ git init`

指令成功指令后目录下会多出一个名为`.git`的目录，该目录记录了版本库的各种信息，不要随意修改。

### 提交到版本库
向版本库提交改动需要以下几个步骤：

0. 添加有改动的文件： `$ git add [文件路径]`
0. 执行提交操作： `$ git commit`

如果进行了错误的操作，在提交之前，可以放弃缓冲区的更改：

`$ git reset`

在提交时可一同添加提交说明，使用：

`$ git commit -m [提交说明]`

如果需要修改提交说明，使用命令修改最近一次的提交说明：

`$ git commit --amend`

### 重命名版本库中的文件
版本库中的文件**不能**直接使用Unix的`rm`、`mv`等命令进行操作。
使用`mv`重命名文件后，`Git`会认为原文件在版本库中被**删除**了，原文件的在版本库内的记录不会继续到重命名后的新文件上。

在版本库内重命名文件应使用`Git`提供的指令：

`$ git mv [源文件名] [新文件名]`

### 修改历史提交说明
要修改历史版本的提交说明，首先要重构目标提交说明所在的提交的前一次提交。

修改历史提交说明，需要执行以下步骤：

0. 执行`git rebase -i [commit_id]`，之后会进入交互式的历史提交查看页面，在这个页面将要修改的提交说明前的`pack`字段改为`edit`。
0. 字段修改完毕后，`Git`会自动支跳转到该次提交，执行`git commit --amend`像往常提交了错误的提交说明一样修改提交说明。
0. 之后重新构建提交，执行`git rebase --continue`，`Git`又会重新跳转到最近的提交，历史提交说明修改完成。

### 忽略工作目录中特定文件
默认情况下，`Git`会将工作目录中的**所有文件**视为目标文件，一旦有文件处于未跟踪状态，便会给予提示(存在尚未跟踪的文件)。

要想让`Git`忽略某些文件，可以在工作目录中创建`.gitignore`文件，将忽略文件的文件名分行写入其中(一行一个文件名)。

`.gitignore`文件内的忽略文件支持`Unix`文件名匹配规则，可以使用`*`、`?`等操作符匹配多个文件名。
`.gitignore`文件自身也可加入到忽略列表中。

查看到文件状态，使用命令：

`$ git status -s`

`??`符号代表的即是未跟踪的文件。

### 查看/比较版本库
查看当前暂存区的状态：

`$ git status`

显示某个版本的具体变化：

`$ git show [commit_id/标签名]		//不写commit_id时默认为显示最近一次提交的详细信息`

比较文件当前状态与版本库中的区别：

`$ git diff		//该命令可以看到当前文件与最近一次的提交版本有哪些区别`

比较不同版本/分支：

```
$ git diff [commit_id] 						//将当前版本与指定commit进行比较
$ git diff [commit_id1] [commit_id2] 		//将两个commit版本进行比较
$ git diff [分支名1] [分支名2] 				//将两个分支进行比较
```

### 版本管理
交互式查看版本库的历史提交记录和`commit_id`：

`$ git log`

只查看每次的`commit_id`：

`$ git log --pretty=oneline`

根据每次提交的`commit_id`回退到历史版本：

`$ git reset --hard [commit_id]`

回退到历史版本之后，将不能在`git log`指令中看到自回退版本之后的`commit_id`，若需要之后的`commit_id`，执行指令：

`$ git reflog`

给最近一次提交的版本添加版本标签：

`$ git tag [标签名]`

默认是不添加版本标签说明的，如果需要添加标签说明可以：

`$ git tag [标签名] -m [版本说明]`

给指定某次提交添加版本标签：

`$ git tag [标签名] [commit_id]`

如果不需要某个标签了，可以删除：

`$ git tag -d [要删除的标签名]`

### 查看文件改动
查看具体某一个文件的历史改动：

`$ git log [文件名]`

查看文件改动同时显示具体变更内容：

`$ git log -p [文件名]`

### 分支管理
查看当前所处的分支：

`$ git branch`

查看所有的分支(包括远程分支)：

`$ git branch -a`

创建分支：

`$ git branch [分支名]`

切换分支：

`$ git checkout [分支名]`

创建分支同时切换到新的分支：

`$ git checkout -b [分支名]`

合并某分支到当前分支：

`$ git merge [分支名]`

删除分支：

`$ git branch -d [分支名]`

### 暂存变更
当修改了工作区中的文件，尚未提交，而远程仓库中此文件同样有改动时，将远程仓库`pull`到本地会提示文件冲突。

0. 先使用`git stash`将本地修改暂存。
0. 使用`git stash`之后，工作区会恢复到最近一次提交，所有的改动都被保存，工作区重新变为`clear`。
0. 再次进行`pull`操作，将远程仓库拉取到本地。
0. 最后运行`git stash pop`将之前暂存的改动重新应用到当前工作区。



## 管理远程仓库
使用`git remote`相关指令可以进行远程仓库的相关操作。

`Git`的远程仓库服务基于`SSH`，因此远程仓库的主机上必须安装并启动了**SSH服务**。
远程仓库的地址需要符合SSH地址的规范，即写成`ssh://用户名@ip地址/绝对路径`的形式。

### 拷贝远程仓库
使用SSH协议复制目标主机的指定仓库：

`$ git clone [SSH地址]`

### 查看远程仓库
查看所有的远程仓库：

`$ git remote`

查看某个远程仓库的具体信息：

`$ git remote show [远程仓库名称]`

### 远程分支相关操作
创建一个远程仓库：

`$ git remote add [远程仓库名] [远程仓库地址]`

如：`git remote add NetRepo ssh://root@192.168.1.199/root/Notes`即创建了一个目标主机地址为`192.168.1.199`、用户为`root`、仓库地址为目标主机的`/root/CodeNotes`目录的远程仓库。

重命名远程仓库：

`$ git remote rename [旧仓库名称] [新仓库名称]`

删除远程仓库：

`$ git remote remove [远程仓库名称]`

### 推送/接收远程分支
推送一个本地分支到远程仓库的指定远程分支上：

`$ git push [远程仓库名] [本地分支名称]:[远程分支名称]`

若本地仓库与远程仓库存在同名分支，则可以简写为：

`$ git push [远程仓库名] [同名分支]`

接收远程分支更新并进行合并：

`$ git pull [远程仓库名] [远程分支名称]`

默认情况下，会将远程仓库推送的分支与本地仓库的同名分支进行合并。
`git pull`实际相当于两次操作：

0. `$ git fetch [远程仓库名]`
0. `$ git merge [远程仓库名/分支名称]`

如果设置了追踪关系，则可以省略远程分支名：

`$ git pull [远程仓库名]`

如果存在唯一的追踪关系，则可以省略所有参数：

`$ git pull`

追踪关系可以手动设定：

`$ git branch --set-upstream [本地分支] [远程仓库名/远程分支名]`

### 创建/删除远程分支
推送本地分支到一个不存在的远程分支上，便会令远程仓库创建该分支：

`$ git pull [远程仓库名] [本地分支名称]:[要创建的远程分支名称]`

若推送**空本地分支**给对应远程仓库的指定分支，则会删除远程仓库的指定分支：

`$ git pull [远程仓库名] :[远程分支名称]`

在`Git 1.7`之后，可以使用指令删除远程分支，作用相同：

`$ git pull [远程仓库名] --delete [远程分支名称]`

### 强制覆盖远程分支内容
强制覆盖分支的内容需要修改远程仓库中的`receive`配置：

`$ git config receive.denyCurrentBranch ignore`

同时，本机在执行`push`操作时使用`--force`参数：

```
$ git push [远程仓库名] [同名分支] --force
$ git push [远程仓库名] [本地分支名称]:[远程分支名称] --force
```

若未使用`--force`参数，分支内容合并有冲突时依旧会拒绝合并而非强制覆盖。



## 使用`GitHub`
`GitHub`是一个当下流行的提供免费`Git`仓库托管服务的网站。本地的`Git`仓库可以方便地托管到`GitHub`上。

### 创建GitHub仓库
注册完`GitHub`帐号之后，在`Repositories`页面中即可创建`GitHub`个人仓库。

### 生成SSH本地密钥
本地Git仓库与GitHub仓库之间的传输是通过SSH加密的，需要在本地生成SSH的**公钥**和**私钥**。

使用`ssh-keygen`命令生成密钥：

`$ ssh-keygen -t rsa -C [GitHub邮箱名称]`

生成密钥的过程中会有选项，全部回车默认即可。

命令执行结束之后会在本地家目录下的`.ssh`文件夹下生成两个密钥文件：`id_rsa`和`id_rsa.pub`。

将公钥`id_rsa.pub`中的内容复制到GitHub个人设置中的`SSH keys`页面中。

需要注意的是，`id_rsa`以及`id_rsa.pub`文件的权限必须设置为**仅当前用户可见**(`600`)，如果密钥文件其他用户、用户组可见则无法完成同步操作。

### 推送本地仓库
添加完密钥之后，查看已创建的仓库的SSH地址，比如我的笔记仓库地址即为`git@github.com:dainslef/Notes.git`，将这个地址添加到远程仓库中：

`$ git remote add [远程仓库名] [远程仓库地址]`

以GitHub作为远程仓库名，自己的仓库做地址，即输入命令：

`$ git remote add GitHub git@github.com:dainslef/CodeNotes.git`

添加远程仓库完毕，即可推送本地分支到GitHub上了：

`$ git push [远程仓库名] [分支名称]`

将本地的dev分支推送到GitHub上即为：

`$ git push GitHub dev`

若GitHub上创建的仓库非空(比如创建仓库的同时加入了许可证文件)，则可能推送失败(文件冲突)，此时可以先将本地版本库拉到GitHub上对应分支的版本：

`$ git pull [远程仓库] [分支名称]`

执行后会提示合并，提交后再进行推送。

### 关于提交者
本地`.gitconfig`文件中的邮箱最好设置成与GitHub账户邮箱相同，否则头像等信息不会在GitHub的提交界面显示出来。

只有本地提交邮箱与GitHub账户设置的邮箱相同时，才会被认为是当前账户的操作。