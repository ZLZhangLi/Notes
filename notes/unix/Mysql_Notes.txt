mysql初始化 >>
在mysql 5.7之后，windows下首次使用mysql数据库之前需要使用命令初始化(mysql 5.6版本之前不需要)：
> mysqld --initialize

初始化之后会创建随机密码的本地root用户，并且初始化不会再创建空用户。
创建的用户密码可以从 xxx.err 文件中查看，日志内容大致为：
[Note] A temporary password is generated for root@localhost: [password]

使用如下指令初始化可以创建不带有密码的root账户：
>  mysqld --initialize-insecure


在Linux下手动安装mysql >>
在Linux下使用非发行版包管理安装的Linux需要执行类似的操作，下在mysql的tar.gz包，解压之后在mysql安装路径下，创建data目录，之后进入bin目录，执行初始化操作(创建了空密码的本地root用户)：
$ ./mysqld --initialize-insecure --basedir=.. --datadir=../data
之后使用一个路径作为锁(路径可以不存在)，以普通用户权限启动服务：
$ ./mysqld --basedir=.. --datadir=../data --socket=../lock
登陆数据库时同样需要指定锁文件：
$ mysql --socket=../lock -u root

也可以将配置写入 安装路径/support-files/my.cnf 文件，写入如下配置指定启动路径：

[mysqld]
basedir = ..
datadir = ../data
# port = .....
# server_id = .....
socket = ../support-files/sock_lock

sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES

[server]
character_set_server = gbk

[client]
default-character-set = gbk
socket = ../support-files/sock_lock

每次启动服务添加--defaults-file='配置文件路径'参数使用指定配置启动：
$ ./mysqld --defaults-file=../support-files/my.cnf
登陆操作类似
$ ./mysql --defaults-file=../support-files/my.cnf -u [用户名] -p

========


mysql的服务管理 >>
mysql的服务管理根据发行版的不同，操作方式也不尽相同。

----

在ArchLinux中使用mysql >
在Archlinux下，登录mysql之前需要启动mysql服务：
(启动mysql服务时需要以root用户启动，否则会一直显示正在启动而无法启动成功！)
# cd /usr/share/mysql
# ./mysql.server start
其它的mysql服务状态命令：
# ./mysql.server stop				//停止mysql服务
# ./mysql.server reload				//重新加载服务
# ./mysql.server restart			//重新启动服务

----

在基于systemd的发行版中使用mysql >
在Archinux和Fedora等采用systemd作为服务管理系统的发行版中，可以使用systemd提供的服务管理指令来管理mysql服务：
# systemctl start mysqld			//开启mysql服务
# systemctl stop mysqld				//停止mysql服务
# systemctl reload mysqld			//重新加载mysql服务
# systemctl restart	mysqld			//重新启动mysql服务
在Ubuntu 15.04之后也采用systemd作为服务管理系统，但在ubuntu中，mysql的服务名称并不是mysqld而直接是mysql。
mysql服务的名字为mysqld，可以将mysql服务设置为开机自启动：
# systemctl enable mysqld
停止mysql服务开机自启动：
# systemctl disable mysqld

----

在基于SysVinit的发行版和FreeBSD中使用mysql >
在CentOS6等旧式发行版中，采用的是SysVinit作为服务管理，也有对应指令进行服务管理：
# service mysqld start				//开启服务
# service mysqld restart			//重新加载服务
# service mysqld stop				//停止服务

----

在Windows中使用mysql >
在Windows中使用mysql需要将mysql的安装目录下的bin文件夹加入环境变量PATH中。
> mysqld							//开启服务
> mysqladmin -u [具有管理员权限的用户名] -p		//使用管理员账户关闭服务
安装mysqld为windows系统服务：
> mysqld --install
使用windows服务管理启动mysql：
> net start mysql

----

登录与配置数据库 >
成功启动mysql服务之后，可以使用命令登录数据库：
# mysql -u root
在Archlinux中，默认root用户是没有密码的，进入数据库命令行中，输入：
set password = password('015');
然后退出数据库，即可将密码设置为015。
或者使用mysqladmin命令：
$ mysqladmin -u root password '015'
设置了密码之后下此再以root用户登录数据库时，需要使用 mysql -u root -p 来登录，否则会报错。
当设置了密码之后再次使用mysqladmin命令修改密码时需要添加-p参数，并需要输入先前的密码：
$ mysqladmin -u root -p password '015'

远程登陆 >
远程登陆使用指令与本地登陆类似，但需要服务端创建了允许远程登陆的账户，登陆时需要使用-h参数指明需要登陆的主机地址：
$ mysql -h [主机ip] -u [用户名] -p

----

mysql的驱动配置 >
在Netbeans之类的IDE中启动mysql，需要加载jdbc驱动到库中。
在Ubuntu发行版中使用qtcreator开发Qt5程序，需要安装libqt5sql-mysql包。
在Linux发行版中，使用C API连接mysql数据库时需要安装额外的开发包才能有对应的头文件，在debian系中，执行指令：
# apt-get install libmysqlclient-devel
在RedHat系发行版中，执行：
# yum/dnf install mysql-devel
在ArchLinux中不需要，ArchLinux将头文件与库与数据库本身一同打包。

========


mysql的账户管理 >>

查看用户信息 >
mysql数据库中，账户的信息保存在mysql数据库的表user中，查询该表即可得到用户信息。
select * from mysql.user;

----

创建用户 >
在mysql中创建用户分为创建本地账户和创建远程账户两种，默认创建的是远程账户：
create user [用户名];					//创建一个不允许本地登录的远程账户
相当于：
create user [用户名@'%'];
创建本地账户：
create user [用户名@localhost];

----

删除账户 >
删除一个远程账户：
drop user [用户名@'主机名/主机地址'];
删除一个本地账户：
drop user [用户名@localhost];
删除一个空用户名的账户：
drop user [''@'主机名/主机地址'];

----

授权用户 >
默认情况下，新创建的用户是没有权限的，使用root账户登录数据库中对新创建的账户进行授权。
授予账户某个数据库的查询和更新的权限：
grant select,update on [数据库名].* to [用户名]@[登录方式];
授权某个账户所有权限：
grant all privileges on *.* to [用户名]@[登录方式];
被授权的用户默认不能将所拥有的权限授权给其它用户，如果需要使授权能够被传播则使用(一般不推荐这样使用，数据库权限应由DBA统一管理)：
grant all privileges on *.* to [用户名]@[登录方式] with grant option;
非root用户可能没有授权其它账户的权限，可以通过修改mysql.user表来赋予权限：
update user set Host='[主机名称]',select_priv='y', insert_priv='y',update_priv='y', Alter_priv='y',delete_priv='y',create_priv='y',drop_priv='y',reload_priv='y',shutdown_priv='y',Process_priv='y',file_priv='y',grant_priv='y',References_priv='y',index_priv='y',create_user_priv='y',show_db_priv='y',super_priv='y',create_tmp_table_priv='y',Lock_tables_priv='y',execute_priv='y',repl_slave_priv='y',repl_client_priv='y',create_view_priv='y',show_view_priv='y',create_routine_priv='y',alter_routine_priv='y',create_user_priv='y' where user='[用户名]';
更新完用户权限表之后，刷新权限信息：
flush privileges;

----

查看权限 >
显示当前用户的权限信息：
show grants;
显示其它用户的权限：
show grants for [用户名]@[主机地址];

========


mysql数据库的常用操作 >>

mysql注释 >
单行注释 --
多行注释 /* */

----

常用的数据库指令 >
status;							//查看数据库基本状态
show databases;					//查询有哪些数据库
create database [数据库名];		//创建数据库
drop database [数据库名];		//删除数据库
use [数据库名]					//切换正在使用的数据库
desc [表名];					//查看表格的结构
truncate table [表名];			//清除指定表格的内容(速度快，但不可恢复)
delete from [表名];				//删除指定表格的内容(速度慢，但可以恢复)

----

常用的sql语句 >
insert into [表名] ([列名1], [列名2], ....) values([值1], [值2], ....);		//插入值是字段加单引号，数值则不用
update [表名] set [列名] = '[内容]' where [列名] = '[内容]';				//更新符合条件的记录
select count(*)	from [表名];												//查询表中共有多少条记录
alter table [表名] add column [列名] [字段类型];							//添加列
alter table [表名] drop column [列名];										//删除列
delete from [表名] where [限制条件];										//删除满足限制条件的行

----

查询数据库信息 >
查询当前登录的用户：
select user();
查询正在使用的数据库名称：
select database();
查询数据库版本信息：
select version();
查询数据库编译平台：
select @@version_compile_os;

----

设置与取消主键自增 >
设置主键自增：
alert table [表名] auto_increment=[数字];			//设置自增属性
alter table [表名] change [主键列名] [主键列名] [属性] auto_increment;
取消主键自增：
alter table [表名] change [列名] [列名] [属性];
设置属性时添加自增属性对于已有的列，必须清空数据才能正常设置自增属性。
被设置自增属性的列必须是主键。

----

为已建好的表加上唯一性约束 >
alter table [表名] add unique([列名]);

----

备份和还原数据库 >
导出所有数据库：
$ mysqldump -u [数据库用户名] -p -A > [备份文件的保存路径]
导出某一个数据库：
$ mysqldump -u [数据库用户名] [要备份的数据库名称] -p > [备份文件的保存路径]
例子：mysqldump -u root -p test > d:\test.sql (注意：此备份只备份数据和数据结构，没有备份存储过程和触发器)
只导出数据不导出数据结构：输入：mysqldump -u [数据库用户名] -t [要备份的数据库名称] -p > [备份文件的保存路径]
还原数据库时需要先登陆mysql用户，选择数据库后执行：source [备份文件的保存路径]
导入数据库时需要注意，登陆数据库使用的连接编码需要与导入的数据库编码相同，否则可能乱码。
导出数据库时需要注意，导出的sql文件的文本编码与数据库自身的编码需要相同，否则使用source导入时可能会出现乱码问题。

----

设置超时连接时间 >
在mysql中，如果一段时间没有与数据库进行交互，则服务端会自动关闭数据库连接(超时关闭)，这个超时时间可以由 wait_timeout/interactive_timeout 两个参数决定。
默认情况下，超时连接的时间为 28800 秒，也就是8个小时。
在数据库命令行界面中使用：
> show global variables like '%timeout%';
即可以查询当前数据库设置的超时连接数值。
在数据库命令行中使用：
> set global wait_timeout = [需要的超时时间];
> set global interactive_timeout = [需要的超时时间];
即可将mysql的超时时间设置为需要的值。

----

关于 "Another MySQL daemon already running with the same unix socket" 服务启动错误 >
在mysql服务启动的情况下，如果机器没有正常关机，下次开机启动mysql服务很可能会出现错误:
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock'
的错误，原因是服务的mysql.sock文件已经存在，会让系统认为已经有一个mysql在默认的端口启动了。

========


中文编码支持 >>
默认情况下，旧版的mysql数据库的编码为latin1，此编码不支持东亚语系的文字显示，需要修改为支持各国文字的UTF-8编码。
对于部分使用MariaDB的发行版(如ArchLinux)，默认的编码为UTF-8，无需额外配置。
查看数据库的默认的所有编码信息：
show variables like 'character_set_%';

典型的结果如下所示：
+--------------------------+------------------------------------------------------------+
| Variable_name            | Value                                                      |
+--------------------------+------------------------------------------------------------+
| character_set_client     | gbk                                                        |
| character_set_connection | gbk                                                        |
| character_set_database   | gbk                                                        |
| character_set_filesystem | binary                                                     |
| character_set_results    | gbk                                                        |
| character_set_server     | gbk                                                        |
| character_set_system     | utf8                                                       |
| character_sets_dir       | D:\ProtableApplication\mysql-5.6.21-winx64\share\charsets\ |
+--------------------------+------------------------------------------------------------+

其中character_set_client、character_set_connection、character_set_database、character_set_results、character_set_server可以通过修改配置文件中的[server]、[client]段进行修改。

需要注意的是，每个数据库可以拥有不同的编码信息，查看指定数据库的编码：
use [数据库名称];
show variables like 'character_set_database';
修改指定数据库的编码：
alter database [数据库名称] CHARACTER SET [编码类型(gbk/utf8)];

----

修改数据库编码 >
如果需要将数据库的默认编码设置为UTF-8，则需要修改配置文件。
在Debian/Ubuntu系中，配置文件为 /etc/mysql/mariadb.conf.d/client.cnf 。 在RedHat系中，配置文件为 /etc/my.cnf 。
在ArchLinux中，配置文件为 /etc/mysql/my.cnf 。
在其中加入配置：
[client]
# Default is Latin1, if you need UTF-8 set this (also in server section)
default-character-set = utf8
[server]
default-character-set = utf8

在Windows系统下，配置文件在mysql安装路径的根目录下，名称为 my.ini ，默认情况下不会创建此配置文件，可以复制同路径下的默认配置 my-default.ini 中的内容。
在其中加入以下配置：
[server]
# mysql5.5版本之后[server]配置段不再使用default-character-set=utf8，该配置已被废弃
character_set_server = utf8
[client]
# 客户端配置不变
default-character-set = utf8

[client]段的配置影响character_set_client、character_set_connection、character_set_results的编码。
[server]段的配置影响character_set_database、character_set_server的编码。

----

JDBC连接编码设置 >
使用JDBC往mysql中写入中文数据时需要注意mysql的编码问题，编码问题体现在以下几个方面：

1.数据库表的编码，ENGINE=InnoDB DEFAULT CHARSET=utf8;
2.数据库连接的编码，jdbc:mysql://localhost:3306/xxx?useUnicode=true&characterEncoding=UTF-8
3.页面提交内容的编码, request.setCharacterEncoding("UTF-8");response.setCharacterEncoding("UTF-8");

数据库表的内容真实编码需要与数据库的编码设置(character_set_database)相同，而数据库使用的连接编码也需要与数据库的真实编码相同。
JSP的页面显示编码可以自行指定，只要保证从数据库中以正确的编码格式读取出了正确的数据即可。

========


向mysql中添加图片 >>
如果需要向数据库中插入图片，则字段应该选择BLOB类型。
BLOB(binary large object)，二进制大对象，是一个可以存储二进制文件的容器。
在mysql中，与BLOB相关的类型有四种：TinyBlob、Blob、MediumBlum、LongBlum，这几个类型的区别在于存储文件的大小上限不同，TinyBlob最大255B，Blob最大65KB，MediumBlob最大16MB，LongBlob最大4GB。

========


使用C风格API访问mysql数据库 >>
mysql数据库提供了标准的访问方式，包含头文件 /usr/include/mysql/mysql.h 即可使用mysql的C语言绑定。
使用Unix工具链进行编译时，需要添加参数 -lmysqlclient 链接 libmysqlclient.so 动态库。

----

常用的变量类型 >
MYSQL 存储相关连接信息
MYSQL_RES 存储返回值相关信息

----

连接数据库 >
MYSQL* mysql_init(MYSQL *mysql);
MYSQL* mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag);
建立连接使用需要首先使用mysql_init()进行初始化操作，如果初始化的是一个MYSQL*指针，则参数填NULL，然后将返回值赋值给需要被初始化的指针；如果初始化的是一个MYSQL结构体，则直接将结构体变量的地址做为参数传入mysql_init()函数中。
执行mysql_init()成功则返回MYSQL句柄指针，内存不足时执行失败返回NULL。
初始化操作完成后可以使用mysql_real_connect()进行数据库连接，连接成功返回0，失败返回错误代码。
mysql_real_connect()中port参数用于显式指定连接端口，unix_socket为socket连接类型，clientflag为mysql运行ODBC的标记，一般本地连接这三个参数全填0。
需要注意的是mysql_connect()已不推荐使用，仅仅为了兼容而保留。

----

执行SQL语句 >
int mysql_query(MYSQL *mysql, const char *q);
int mysql_real_query(MYSQL *mysql, const char *q, unsigned long length);
一般性的sql语句可以直接使用mysql_query()执行，q参数为需要执行的sql语句字符数组指针。
mysql_real_query()相比mysql_query()而言效率更高，因为其不调用strlen()来获取字符数组长度。
两个函数在执行成功时返回0，执行失败时返回错误代码。
需要注意的是，如果执行的sql语句中包含有二进制内容，则一定需要使用mysql_real_query()，因为mysql_query()会调用strlen()来获取字符数组长度，而strlen()判断字符数组结束是以"\0"作为标志的，但对于二进制数据而言，数据中是可能带有"\0"的，因而使用mysql_query()可能会造成对数据长度的误判使得程序未按预期执行。

----

获取查询SQL语句的返回内容 >
MYSQL_RES* mysql_store_result(MYSQL *mysql);
MYSQL_RES* mysql_use_result(MYSQL *mysql);
unsigned int mysql_field_count(MYSQL *mysql);
unsigned int mysql_num_fields(MYSQL_RES *res);
MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);
mysql_store_result()和mysql_use_result()都可以获取执行查询语句之后的结果集内容，如果没有返回内容则返回NULL。
mysql_field_count()用于获取最近查询的列数，mysql_num_fields()用于获得指定查询结果的列数。
得到结果集之后使用mysql_fetch_row()按行读取结果集中的内容，每次执行mysql_fetch_row()会返回下一行的内容，返回值类型MYSQL_ROW的实际类型为二维指针char**，保存了每一列的字符数组指针。
mysql_store_result()与mysql_use_result()之间的区别是，前者会将结果集拷贝到本地，开销大，后者直接读取服务器中的数据，每次只拷贝一行，开销小，但是后者需要在下一次SQL语句执行之前将结果集中的数据全部读出，但前者就不需要。

----

切换当前数据库 >
int mysql_select_db(MYSQL *mysql,const char *db);
切换选择的数据库，相当于mysql指令 "use [数据库名]" 。

----

关闭数据库连接 >
void mysql_close(MYSQL *sock);
如果传入的参数是指针，则指针所指向的MYSQL结构体内存区域会被释放掉。
立即访问执行mysql_close()之后的MYSQL指针会报错(野指针)，如果在关闭连接之后需要重新启用连接，需要重新执行初始化操作mysql_init()。