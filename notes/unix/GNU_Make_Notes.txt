在Unix环境下进行大型项目的开发通常使用make工具来构建项目/工程，因此必须学会编写makefile文件。

makefile文件的基本格式为：

target(目标文件): dependency(依赖文件),....
	command(执行指令)

target代表最终生成的目标文件(有一些常见的伪目标比如all、clean、.PHONY)。
dependency代表生成目标文件所需要用到的源文件(依赖文件)。
command代表为了生成目标文件所需要执行的指令，该指令也可以是shell脚本指令。


每次使用make指令时，make工具会对比目标文件与依赖文件的改动时间，如果目标文件不存在或是改动时间在依赖文件之前的话，会执行命令，再次生成目标文件。
注意make工具在分析makefile关系时是自上向下的，也就是说，如果第一个目标文件满足新旧关系，便不会在向下执行剩余的语句，因此，第一个目标文件需要设定为整个工程的最终生成文件。如果一个工程有多个最终生成文件，则可以使用伪目标all。
使用make工具时如果不添加参数，则将第一个目标文件作为最终生成文件，如果需要指定进行某一步的make操作，则应使用"make [目标名]"的方式来指定进行某一步make过程。


makefile中注释跟Bash脚本一样，采用#号进行单行注释。
默认情况下，makefile中执行的指令内容会显示在终端上，在要执行的指令前加上@符号可以关闭该指令内容在终端的显示。

对于经常使用的长指令或是重复目标文件可以采用定义变量的形式：

cc = g++ -std=c++11
a.out: example.o
	$(cc) example.o					#展开后相当与 g++ -std=c++11 example.o
example.o: example.cc
	$(cc) -c example.cc


makefile中的最终目标也可以是伪目标，如伪目标all代表所有目标的目标。
一个makefile如果要编译多个不相关程序，则可将这多个程序作为all目标的依赖，如下所示：
all: app1 app2
app1: ...
app2: ...
可以在编译时分别使用 make app1 以及 make app2 来编译独立的部分。

Makefile隐含规则：
Makefile可以一定程度上自动推导依赖关系，如一个目标文件abc，会自动依赖abc.o，而一个abc.o的目标，会自动依赖abc.c。


像shell脚本一样使用"$(变量名)"的形式来使用变量的内容($符号后的括号不可省略！)。
makefile中有一些常用自动变量：
$@	目标文件
$^	所有的依赖文件
$<	第一个依赖文件
$*	指代匹配符 % 匹配的部分


Unix编译器大多带有推断make关系的功能，例如gcc可以使用-M参数来推断一个源文件的make关系：
$ cc -M [源码文件]


Makefile的通配符与Bash一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。


Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。

%.o: %.c

等同于下面的写法：

f1.o: f1.c
f2.o: f2.c
