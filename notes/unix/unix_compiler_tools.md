[TOC]

## 编译流程
编译器处理代码简单得来说分为以下几个阶段：

1. `Preprocessing` 预处理
1. `Compilation` 编译
1. `Assembly` 汇编
1. `Linking` 链接

### *Preproceessing* 预处理
主要处理包括以下过程：

1. 将所有的`#define`删除，并且展开所有的宏定义
1. 处理所有的条件预编译指令，比如`#if`、`#ifdef`、`#elif`、`#else`、`#endif`等
1. 处理`#include`预编译指令，将被包含的文件插入到该预编译指令的位置
1. 删除所有**注释**`//`和`/* */`
1. 添加**行号**和**文件标识**，以便编译时产生调试用的行号及编译错误警告行号
1. 保留所有的`#pragma`编译器指令，因为编译器需要使用它们

预处理之后得到`*.i`的源码文件。

### *Compilation* 编译
编译过程就是把预处理完的文件进行一系列的**词法分析**、**语法分析**、**语义分析**及优化后生成相应的汇编代码。

编译之后得到`*.s`的汇编源码文件。

### *Assembly* 汇编
汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。  
汇编相对于编译过程较简单，根据汇编指令和机器指令的对照表一一翻译。

汇编之后得到`*.o`的**目标文件**，内容为**机器码**，不能以普通文本形式的查看(用文本编辑器查看则内容为乱码)。
Unix环境下的汇编器为`as`。

### *Linking* 链接
链接程序运行需要的目标文件，以及所依赖的其它库文件，最后生成可执行文件。  
Unix环境下的链接器为`ld`。



## 编译器
在`Unix`环境下，常用的编译环境为`gcc/clang`。二者的命令格式类似。

### 基本编译操作
编译源码的基本命令(一次性执行预处理、编译、汇编、链接等所有过程，直接得到可执行文件)：

```
$ cc [c源码文件] 				//cc为c语言编译器
$ c++ [c++源码文件]				//c++为c++编译器
```

不同的操作系统中对`cc`编译器的实现**不同**。
一般情况下，`cc`指令是一个软链接，指向系统默认的编译器，即使用cc编译器实际调用的是操作系统的默认编译器：

- 在`Linux`中，`cc`软链接指向`gcc`编译器。
- 在`FreeBSD/macOS`中，`cc`软链接指向`clang`编译器。
- 在`Solaris`中，`cc`指令不再是软链接，而是`Solaris`特有的商业闭源编译器。

默认情况下，编译器会生成一个名为`a.out`的二进制可执行文件，运行程序：

```
$ ./a.out
```

若需要指定生成的可执行文件的名称，则需要使用`-o`参数：

```
$ cc [源码文件] -o [指定执行文件的名称]
```

若仅需要编译器进行预处理，则需要使用-E参数：

```
$ cc -E [源码文件]
```

默认情况下，编译器会将预处理的结果直接输出到终端上，如果需要将预处理结果输出到文件中，使用(保存预处理后代码的文件一般用*.i做后缀名)：

```
$ cc -E [源码文件] -o [预处理结果文件名(*.i)]
```

若需要得到编译器生成的汇编代码可以使用`-S`参数：

```
$ cc -S [源码文件]
```

默认情况下生成的是`AT&T`风格的汇编，若需要生成`intel`风格的汇编可以使用参数：

```
$ cc -S -masm=intel [源码文件]
```

若不需要直接生成可执行文件，而是只是生成`*.o`格式的目标文件的话，则需要使用`-c`参数：

```
$ cc -c [源码文件]
```

默认情况下，编译器不会在生成的执行文件中添加调试标记，若需要在生成的二进制文件中保留调试标记，需要使用`-g`参数：

```
$ cc -g [源码文件]
```

使用`-s`参数则生成可执行文件中的不包含符号表(不包含符号表的可执行文件体积更小，适合在发布软件时使用)：

```
$ cc -s [源码文件]
```

这样生成的可执行文件就会包含调试标记，可供`gdb`之类的调试器进行调试：

```
$ gdb [生成的可执行文件]
```

### 库文件
在Unix环境中，系统的库文件一般存放在`/lib`、`/lib64`、`/usr/lib`等目录下，库文件分为以下两种类型：

- **动态链接库**，后缀名为`so`意为`share object`(共享对象)。
- **静态库**，后缀名为`a`意为`archive`(档案文件)。

动态链接库可以由编译器生成：

```
$ cc -shared -fPIC [源码文件] -o [生成动态库的名字]
```

静态库则使用archive实用工具`ar`来创建，需要先将源码编译成目标文件，再使用`ar`命令：

```
$ ar crs [生成静态库的名字] [目标文件]
```

在Unix环境中，库的命名方式一般为`lib+[库名]`，在编译时如果需要使用链接库，需要`-l`参数直接加**库名**而不需要写完整的库文件名字：

```
$ cc [源码文件] -l[库名]
```

如果库的位置不在环境变量中，则需要用-L参数手动指定库所在的目录：

```
$ cc [源码文件] -L[库目录] -l[库名]
```

如果源码中引用的头文件位置不在环境变量中，则需要用`-I`参数手动指定头文件所在的目录：

```
$ cc [源码文件] -I[头文件目录]
```

默认情况下，编译器在链接库时优先使用的是动态链接库，如果在某些特别情况下需要使用静态链接库的话，使用`-static`参数强制编译器使用静态库：

```
$ cc -static [源码文件] -l[库名]
```

如果一个程序使用了非系统提供的动态链接库，需要将自己的动态链接库位置加入环境变量中，否则在运行程序时会提示找不到动态链接库。

与Windows不同，Unix系统默认情况下不会在可执行文件所处的路径中寻找动态链接库，如果需要可执行文件加载当前路径下的动态库，则需要将当前目录也加入`LD_LIBRARY_PATH`环境变量中：

```
$ export LD_LIBRARY_PATH=./
```

需要注意的是，该命令会在`logout`之后失效，长期使用可已考虑写入`.xprofile`或`.profile`文件中。

静态链接库由于在编译阶段已经将库文件包含在可执行文件中，所以不会出现类似问题。

使用`ld`命令连接目标文件(*.o)和库：

```
$ ld [目标文件] -l[库名]
```

也使用`libtool`工具生成动态库和静态库。

使用`ldd`命令可以查看一个可执行文件用到了哪些动态链接库：

```
$ ldd [可执行文件]
```

使用`nm`命令可以显示关于对象文件、可执行文件以及对象文件库里的符号信息(符号表)：

```
$ nm [可执行文件]
```

`nm`指令的常用参数：

- `-A` 在每个符号信息的前面打印所在对象文件名称
- `-C` 输出解码过的符号名称，能够以易于理解的方式显示`C++`函数名
- `-D` 打印动态符号
- `-l` 使用对象文件中的调试信息打印出所在源文件及行号
- `-n` 按照地址/符号值来排序
- `-u` 打印出那些未定义的符号

常见的符号类型：

- `A` 该符号的值在今后的链接中将不再改变
- `B` 该符号放在BSS段中，通常是那些未初始化的全局变量
- `D` 该符号放在普通的数据段中，通常是那些已经初始化的全局变量
- `T` 该符号放在代码段中，通常是那些全局非静态函数
- `U` 该符号未定义过，需要自其他对象文件中链接进来
- `W` 未明确指定的弱链接符号，同链接的其他对象文件中有它的定义就用上，否则就用一个系统特别指定的默认值

### 反汇编
在`Linux`下，使用`objdump`工具可以对`ELF`二进制文件进行反汇编，以`ArchLinux`为例，安装`objdump`：

```
# pacman -S binutils
```

`objdump`工具的常见参数：

- `-a` 查看档案文件(`*.a`静态库)的详细信息
- `-C` 将底层符号名解码成用户级名称，让`C++`函数名以能够被理解的方式显示出来
- `-d` 查看二进制文件的反汇编代码
- `-D` 查看二进制文件的反汇编代码，包括所有`section`
- `-g` 显示调试信息
- `-e` 显示调试信息，生成的信息格式与`ctags`兼容
- `-r` 显示文件的重定位入口，只能用于静态库
- `-R` 显示文件的动态重定位入口，用于动态链接库和可执行文件
- `-s` 以16进制形式查看可执行文件内容

### macOS下的 *otool*
在`macOS`下，二进制格式为`Mach-O`，`macOS`没有提供`objdump`、`ldd`等工具。

使用`otool`工具代替`objdump`进行反汇编：

```
$ otool -Vt [二进制文件]
```

使用`otool`工具代替`ldd`显示文件链接了哪些动态库：

```
$ otool -L [二进制文件]
```

### 优化级别
在编译程序时，可以为程序添加代码优化选项来提升程序的运行效率。

gcc和clang都有`O1`、`O2`、`O3`三个代码优化级别，`O1`最低，`O3`优化最高。

使用优化选项能大幅度提升生成二进制文件的执行效率，但会使得生成的程序难以调试。故一般只在程序完成测试之后进入发布阶段才会启用编译优化选项。

### 其它编译器参数
其它常用的编译器参数如下：

- `-W` 警告选项，常用的是`-Wall`，开启所有警告。
- `-M` 将文件依赖关系输出到标准输出，输出的文件依赖可以被构建工具`make`使用。
	1. `-M` 默认会输出所有的头文件路径，包括`#include<>`和`#include""`。
	1. `-MM` 仅输出`#include""`的头文件路径。
	1. `-MD` 将依赖关系输出重定向到依赖关系文件`[文件名].d`，通常与`-M`或`-MM`一同使用。



## *Objective-C* 编译
主流的编译器同样支持`Objective-C`语言，`Objective-C`语言的源码为`*.m`。

### 环境安装
要让编译器顺利的编译`Objective-C`的源码，需要安装对应开发库，在Linux系统中是`GNUstep`库。

使用`gcc`编译`Objective-C`源码，需要安装`gcc`的`Objective-C`支持包`gcc-objc`。

以`ArchLinux`为例，安装`Objective-C`开发环境：

```
# pacman -S gcc-objc gnustep-core
```

### 编译参数
编译`Objective-C`的源码相对编译C/C++源码而言要更复杂，需要使用更多的编译器参数。

使用`gnustep-config --objc-flags`指令会自动生成编译`Objective-C`源码需要的编译器参数，将指令的结果插入`gcc`编译指令的参数中。

一般情况下，需要链接`libgnustep-base`、`libobjc`这两个库，如果源码使用了GUI库还需要链接`libgnustep-gui`库。

`gcc`编译`Objective-C`源码指令：

```
$ gcc $(gnustep-config --objc-flags) -lobjc -lgnustep-base [源码文件]
```

由于`gnustep-config`是与`GNU编译器`组配套的，故其生成的编译参数并不完全适用于`clang`编译器，故需要手动指定编译参数以符合`clang`编译器的要求，根据编译器输出的异常信息将`gnustep-config`指令生成的参数中不符合要求的参数剔除，并加入其他需要的编译器参数。

`clang`编译`Objective-C`源码指令(以`Archlinux x64`和`gcc 4.9.2`为例)：

```
$ clang -fconstant-string-class=NSConstantString -lgnustep-base -lobjc -I/usr/lib/gcc/x86_64-unknown-linux-gnu/[gcc-version]/include [源码文件]
```