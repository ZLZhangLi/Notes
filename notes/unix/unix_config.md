## *fdisk*
`fdisk`是Linux命令行下常用的交互式分区工具。

早期的`fdisk`不能识别`GPT`分区表，划分`GPT`分区需要使用`parted`工具。
新版的`fdisk`已经能够正常识别、显示与创建`GPT`分区。

使用`fdisk`显示分区信息：

`# fdisk -l [磁盘路径]`

进行具体的磁盘分区操作需要进入`fdisk`会话：

```
# fdisk							//直接进入fdisk会话，选择第一块硬盘为当前硬盘
# fdisk [磁盘路径]				//进入fdisk会话，并选择指定硬盘为当前硬盘
```

在`fdisk`会话中，操作指令同样会以对话的形式引导完成操作。
基本指令如下：

- `m` 显示指令菜单
- `n` 创建分区
- `d` 删除分区
- `l` 列出已知的分区类型
- `F` 列出未分配的磁盘空间
- `p` 打印分区信息，输出结果与在命令行中输入`fdisk -l`相同
- `i` 列出某一个分区的具体信息
- `t` 修改分区类型信息
- `o` 创建DOS分区表
- `g` 创建GPT分区表
- `x` 进入高级功能会话

在`fdisk`中使用`x`指令后进入高级功能会话，常用指令如下：

- `m` 功能不变，显示指令菜单
- `n` 修改分区名称
- `r` 返回主选单

在`fdisk`会话中进行的操作**不是**立即生效的，退出`fdisk`会话之前需要进行确认：

- `w` 将改动真正写入硬盘
- `q` 不保存改动退出



## *parted*
`parted`是Linux下的另一种交互式分区工具，与`fdisk`相比，`parted`一直支持GPT分区表，并且在功能选项上更加丰富，但在交互上没有`fdisk`简便。

使用`parted`显示分区信息：

```
# parted [磁盘路径] print
# parted [磁盘路径] print all				//显示所有信息
```

与`fdisk`工具类似，执行具体的磁盘分区需要进入`parted`会话：

`# parted [磁盘路径]`

`parted`会话中的基本指令如下：

- `help` 显示指令列表
- `help [指令名称]` 显示指定指令的用法
- `select [磁盘路径]` 切换到指定磁盘
- `mklabel [分区表类型]` 创建指定类型分区表，常用的分区表类型为`msdos`和`gpt`
- `mkpart [分区类型(主分区/扩展分区)] [文件系统(可选)] [分区起始位置] [分区结束位置]` 创建分区，正确使用带有参数的`mkpart`指令可直接创建分区，使用不带参数的`mkpart`指令则会以会话的形式引导输入创建分区所需的参数
- `rm [分区号]` 删除指定分区
- `set [分区号] [分区标志] on/off` 添加/删除指定分区的分区标志
- `name [分区号] [分区名称]` 命名指定分区
- `print` 显示分区信息
- `print free` 显示分区信息，包括磁盘中未被使用的空间
- `quit` 退出`parted`会话

相比`fdisk`，`parted`会话中的分区操作是立即执行并生效的，因此更需小心谨慎。



## *LVM*
`LVM`是`Logical Volume Manager`(逻辑卷管理)的简写，是Linux环境下对磁盘分区进行管理的一种机制。

使用`LVM`能够将不同的硬盘上的物理卷(`Physical Volume`，简称`PV`)加入卷组(`Volume Group`，简称`VG`)，在卷组中将其划分为不同的逻辑卷(`Logical Volume`，简称`LV`)，然后在逻辑卷中创建文件系统并进行挂载。

### 配置LVM
配置`LVM`的**基本步骤**：

0. 创建硬盘分区
0. 创建物理卷：`# pvcreate [硬盘路径/分区路径]`(物理卷可以是整个硬盘或是硬盘中的某个分区)
0. 创建卷组：`# vgcreaate [卷组名称] [需要加入卷组的物理卷分区路径]`
0. 创建逻辑卷：`# lvcreate -L [分区大小(xxGB/xxMB/...)] -n [逻辑分区名称] [卷组名称]`
0. 格式化逻辑分区，挂载使用

### 物理卷 *PV*
物理卷`Physical Volume`是在磁盘上**实际存在**的物理分区。

物理卷相关的操作为`pvXXX`系列指令：

```
# pvcreate [硬盘路径/物理分区路径]				//创建物理卷
# pvremove [硬盘路径/物理分区路径]				//移除物理卷
# pvmove [原物理分区路径] [目标物理分区路径]		//将原物理卷中的数据转移到另一物理卷
# pvdisplay									//显示已创建的物理卷
```

- 移除一个物理卷需要先将该物理卷从所属的卷组中移除。
- 移除物理卷前需要保证没有数据存储在该物理卷中，若**要被移除的物理卷**中已有数据，则需要使用`pvmove`指令将该卷中的数据转移到其它卷。

### 卷组 *VG*
物理卷需要加入卷组(`Volume Group`)才能被使用。

卷组相关的操作为`vgXXX`系列指令：

```
# vgcreate [卷组名称] [物理卷路径]				//一个卷组至少需要包含一个物理卷
# vgreduce [卷组名称] [物理卷路径]				//从一个卷组中删除指定的物理卷
# vgremove [卷组名称]							//移除指定卷组
# vgdisplay									//显示所有卷组
```

### 逻辑卷 *LV*
逻辑卷(`Logical Volume`)是`LVM`中实际用于创建文件系统、挂载的分区。
逻辑卷的磁盘路径为`/dev/[逻辑卷所属卷组名称]/[逻辑卷名称]`，使用该路径可以像操作物理磁盘一样对其进行创建文件系统、挂载等操作。

逻辑卷相关的操作为`lvXXX`系列指令：

```
# lvcreate -L [分区大小(xxGB/xxMB/...)] -n [逻辑分区] [卷组名称]			//创建逻辑卷
# lvresize -L +/-[分区大小(xxGB/xxMB/...)] [逻辑分区]	//在原先逻辑卷大小的基础上扩充/缩减指定大小
# lvextend -L [分区大小(xxGB/xxMB/...)] [逻辑分区]		//增加逻辑卷到指定大小(分区大小的数值需要大于原先该逻辑分区的大小)
# lvreduce -L [分区大小(xxGB/xxMB/...)] [逻辑分区]		//减小逻辑卷到指定大小(分区大小的数值需要小于原先该逻辑分区的大小)
# lvremove [逻辑分区]									//移除指定逻辑卷
# lvdisplay											//显示所有逻辑卷
```

- 扩展逻辑卷大小无需卸载、重新挂载文件系统。
- 缩减逻辑卷大小需要重先卸载文件系统之后**同时**缩减文件系统大小和逻辑卷大小，之后重新挂载。



## *curl*
`curl`是一款功能强大的文件传输工具。

基本指令为：

`$ curl [目标文件路径]`

`curl`对于获取的文件会直接以文本的形式输出在终端上，可以使用`-o`参数导出到文件。
对于一些可能需要验证用户权限的协议(如`ftp`)，可以使用`-u`参数添加用户信息，指令格式如下：

`$ curl [目标文件路径] -u [用户名]:[密码] -o [输出文件路径]`

### 使用 curl 操作 FTP
使用`curl`工具进行`FTP`操作：

```
$ curl ftp://[ip/域名] -u [用户名]:[密码]								//列出FTP下的文件、目录列表
$ curl ftp://[用户名]:[密码]@[ip/域名]									//列出FTP下的文件、目录列表(简化)
$ curl ftp://[用户名]:[密码]@[ip/域名]/[文件路径] -o [输出文件路径]			//传输FTP文件到本地指定路径
$ curl ftp://[用户名]:[密码]@[ip/域名] -T [本地文件路径]					//上传本地文件到FTP
```

在上传/下载时，默认情况下会出现进度提示，可添加`-s`参数取消进度提示。

对于一些复杂的FTP功能，需要直接使用FTP**协议指令**来完成。
在`curl`工具中，使用`-X`参数追加协议指令，命令格式如下：

`$ curl ftp://[用户名]:[密码]@[ip/域名] -X "[FTP协议指令]"`

常见的FTP协议指令如下：

| 指令 | 指令功能 |
|:----|:--------|
| dele [FTP文件路径] | 删除FTP内文件 |
| rmd [FTP目录] | 删除FTP内目录 |
| mkd [FTP目录] | 创建FTP目录 |
| list [FTP目录] | 列出FTP目录 |
| rnfr [FTP文件路径] | 重命名FTP文件(第一步，指定需要重命名的文件) |
| rnto [FTP文件路径] | 重命名FTP文件(第二步，指定文件重命名的名称) |

对于协议指令，`curl`会在终端打印协议指令的执行结果(返回值)，FTP协议指令的常见返回值含义如下：

| 返回值 | 说明 |
|:------|:----|
| 250 | 请求的文件操作正常进行，已完成 |
| 257 | 路径已创建 |
| 350 | 请求的文件操作在等待更进一步的信息 |
| 421 | 服务不可用，关闭控制连接 |
| 500 | 语法错误，无法识别命令(包括命令行过长之类的错误) |
| 501 | 参数或变元中有语法错误 |
| 502 | 命令还没有被实现 |
| 503 | 命令的顺序不对 |
| 530 | 无法登录 |
| 550 | 请求的操作无法执行，文件不可用(例如找不到文件，无访问权) |



## *Suspend* 和 *Hibernate*
*Suspend*和*Hibernate*是很容易混淆的两个概念。

- `Suspend`中译**休眠**，休眠状态下，系统将关闭大部分硬件的工作，系统状态将会被保存在`RAM`中。处于休眠状态下的计算机将以极低的功耗运转，但系统仍需要供电。现代计算机**进入休眠状态/从休眠状态唤醒**仅仅需要几秒时间。
- `Hibernate`中译**睡眠**，睡眠即`Suspend to disk`，系统将完全关闭所有硬件，系统状态将被保存在`SWAP`中，处于睡眠状态下的计算机不需要供电，但系统分区时必须分配并挂载了`SWAP`交换区。**睡眠**从硬盘中加载系统状态，对于使用`HDD`的计算机，**进入休眠状态/从休眠状态唤醒**需要几十秒甚至更久。