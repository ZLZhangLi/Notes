"
添加时间:2013-12-20 23:21 PM
@author: dainslef

shell编程新手注意事项：
变量赋值时等号两边不能有空格。不要使用c语言的编程规范来想当然！

使用-x参数可以运行脚本同时输出调试信息：
$ bash -x xxx.sh

使用set可以输出已经定义的所有变量，使用unset删除一个已经存在的变量。

变量支持"+="操作符
a=3
a+=4						#此时a为"34"

bash中数组下标从0开始，zsh中数组下标从1开始
array=(1 2 3)
array+=(4 5 6)				#zsh扩展语法(bash不支持)，数组通过"+="操作符拼接，此时array为"1 2 3 4 5 6"
${#array[@]}				#数组的长度
${#array[*]}				#同样表示数组的长度
$array						#直接使用数组名等价于取数组的第一个元素(bash中，即$((array[0]))或者$[array[0]])或整个数组内容(zsh中)
${arrary[*]}				#返回数组的所有内容，bash/zsh通用语法
$[array[index]]				#指定数组指定下标的内容
$((array[index]))			#作用同上
${array[index]}				#作用同上
$array[index]				#作用同上，zsh扩展语法，bash不支持

在bash中直接取数组名的值返回的是数组第一个元素，而zsh中，返回整个数组的内容。

对于echo语句，换行符 \n 默认不被识别，在bash中需要使用 echo -e 并且在换行字符前加单引号即 '\n'，在zsh中只需加单引号，不必对echo使用 -e 参数。

可以使用反引号消除语句歧义，当一个语句带有管道等复杂表达式时，可以使用反引号扩起整个语句，表示反引号内的内容是一个整体。

使用awk工具可以方便地对文本内容进行处理如字符串切分：
$ echo "123+124" | awk -F'+' '{ print $1 "-" $2 }'
输出 123-124 ，awk工具以+号作为切分字符将字符串切成两个字符变量后以-号重新拼接。
使用NF可以得到切分出内容的数目。

使用 test 指令的符号形式 [ expression ] 来进行条件判断时，注意 [ expression ] 内的表达式不能紧贴着符号，应该与左右两边的符号都留有一个空格的距离。
多个 [ expression ] 条件判断可以使用与或(&&、||)等操作连接，连接多个 [ expression ] 的逻辑操作符可以空行也可以不空行。
如：
if [ expressionA ] && [ expressionB ]
	|| [ expressionC ];
then
	...
fi

使用 [ expression ] 来进行条件判断时，比较字符串时使用 == 及 != 符号，表示两个字符串相同/不同，在bash中可以使用 = 号判断是否相等，作用等价 == 符号(但在zsh中，使用 == 符号需要加引号否则解析出错)；使用 -z -n 判断字符串为空/不为空。在比较数值时，应使用 -lt -le -gt -ge -eq -ne 等符号来比较数值，分别依次代表 小于 小于等于 大于 大于等于 等于 不等于 。

[] 还可用于判断文件状态：
[ -e file ] 文件 file 已经存在
[ -f file ] 文件 file 是普通文件
[ -s file ] 文件 file 大小不为零
[ -d file ] 文件 file 是一个目录
[ -r file ] 文件 file 对当前用户可以读取
[ -w file ] 文件 file 对当前用户可以写入
[ -x file ] 文件 file 对当前用户可以执行
[ -g file ] 文件 file 的 GID 标志被设置
[ -u file ] 文件 file 的 UID 标志被设置
[ -O file ] 文件 file 是属于当前用户的
[ -G file ] 文件 file 的组 ID 和当前用户相同
[ file1 -nt file2 ] 文件 file1 比 file2 更新
[ file1 -ot file2 ] 文件 file1 比 file2 更老

使用 [ $var = "" ] 判断时，如果变量var是空值，则语句就会变成 [ = "" ] ，会出现语法错误，为防止此类情况，需要再嵌套一层[]，即写成 [[ $var = "" ]] 。
或者将变量使用双引号包裹，即写成 [ "$var" = "" ] ，这样即使变量为空也会变成 [ "" = "" ] ，不会造成语法错误。
使用 -e -f -n ... 等等操作比较文件、检查变量时，同样需要注意此类情况。

shell中的等号用于变量赋值时是复制字符串。

$name 是取变量名为 name 的变量的值， $(name) 则是执行名为 name 的指令。进行数值计算时要加括号， $(5+6) 是将 "5+6" 视为一条指令执行并获取指令的返回值，而 $((5+6)) 或 $[5+6] 输出的结果才是进行加法的结果 11 ，这与传统的高级语言有明显区别。

使用 $? 可以得到上一个命令的返回值，命令成功返回值为0。
$# 和 $* 可以分别得到用户输入的指令的参数数量以及参数内容，默认情况下， $1 ~ $9  可以分别代表用户输入的第1个到第9个参数，当用户输入的参数超过9个了，可以使用 shift 命令进行参数移动。

使用 $RANDOM 指令可以获取一个 0~32767 之间的随机数。当需要获取指定范围的随机数时可以采用求余的形式，比如 $[$RANDOM%10] 可以获取 0~9 之间的随机数。

读取用户在终端的输入可以使用 read 命令，比如：
read 变量名
echo $变量名
就会输出用户刚在在终端中键入的内容。

使用set查看定义了哪些变量(不是环境变量)。
已经定义的变量可以使用：
unset 变量名
的方式进行删除。

使用 function 关键字可以定义函数，具体格式如下：
function 函数名()		#实际定义函数也可以省略function关键字
{
	命令
	return 返回值		#可以没有返回值
}
在shell的函数中定义的普通变量依然为全局变量，在函数作用域之外依然可以使用，如果需要将变量的作用域限制在函数之内，需要在定义变量是使用 local 关键字， local 关键字只能在函数内使用。
在zsh中，扩展了 local 关键字的作用，可以在外部代码中使用local定义变量，使用local定义的变量之前若已经以非local的形式定义，则隐藏以非local形式定义的变量而不是改写其值。

shell选择菜单，需要break，否则会一直循环
select var in "xxx1" "xxx2"
do
	if [ $var... ]; then
		...
	else
		...
	fi
	break
done

for循环的几种写法：
假设要遍历1至10,以下两种做法等价：
# 传统的C风格循环
for ((i=1; i<=10; i++)); do
	...
done
# 函数式风格的列表遍历式循环
for i in {1..10}; do
	...
done
需要注意，类似 i++ 这样的写法只有for循环条件语句中才被允许。
基于范围的for循环中，使用 * 号作为遍历目标作用是遍历当前目录下的内容：
for file in *; do
	echo $file		//输出文件名
done
在 bash4.0 之后，在基于范围的循环中支持设置遍历间隔：
# 以2为间隔进行遍历，输出 1,3,5,7,9
for i in {1..10..2}; do echo $i; done
无限循环：
# 与C中的方式相同
for ((;;)); do
	...
done

xxxx > /dev/null 2>&1
作用是执行xxxx指令，并将标注输出重定向到/dev/null，同时输出错误信息。
"2>&1"是令标准错误输出等于标准输出，"&"符号表示等于，"2>&"不能分开写，分开可能会造成指令解析错误。

经典的shell炸弹：
:(){:|:&};:
"

# 简单的小例子

echo 从1到100不是5的整数倍的数的和：

# 采用for循环

a=0
for ((i=1; i<=100; i=i+1))
do
	b=$[$i%5]
	if [ $b != 0 ]; then
		a=$[$i+$a]
	fi
done
echo $a

# 采用while循环

a=1 b=0
while [ $a -le 100 ];
do
	if [ $(($a%5)) -ne 0 ]; then
		b=$(($b+$a))
	fi
	a=$(($a+1))
done
echo $b


if [ $# == 0 ]; then
	echo 你输入的命令没有带参数！
elif [ $# -gt 1 ]			#不能用>=进行数值比较 elif还可以写成else if
then			#then另起一行的话前面的if判断语句可以不必加分号
	echo 你输入的第一个参数是：$1
	shift		#使用shift对参数进行左移操作
	echo 你输入的第二个参数是：$1
else
	echo 你输入了$#个参数，分别是：$*。
fi
