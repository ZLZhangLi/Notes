c++11/14给c++语言带来了许多新的特性，相对传统的c++而言变化很大。


auto关键字 >>
auto关键字可用于类型推断，比如：

auto a = 5;

c++是强类型语言，使用auto关键字定义变量时，变量一定要初始化，这样auto关键字才能顺利推断出变量类型。
auto关键字不能用于类的普通成员变量的类型推导(即使C++11支持非静态成员变量赋初值)。
对于静态成员变量，在C++11中依然不能类内赋初值，因而实际上auto关键字不能用于类成员变量的推导。
auto在c++11中可以作为函数返回类型的占位符(不能直接推断函数返回值类型！)，搭配 -> 符号指定函数返回类型：

auto function() -> int;

auto与decltype关键字搭配可以进行模板表达式进行模板类型推断：

template <typename T, typename V>
auto function(T t, V v) -> decltype(t + v)
{
	return t + v;
}

在c++14中，进一步优化了auto关键字，统一了auto关键字类型推断与decltype表达式推断的方式，使auto关键字可以直接进行函数返回值类型推断(auto直接作为返回值类型)，例如上例中的模板函数在c++14中不必借助 -> 符号和decltype关键字进行显式的类型推断了，可直接写成：

template <typename T, typename V>
auto function(T t, V v)
{
	return t + v;
}

需要注意的时，当一个函数有多个return语句时，需要保证各个return语句提供的返回值类型相同，否则编译会报错。
此外，auto关键字不能用于虚函数的返回类型推断。

----


统一的begin()和end()函数 >>
c++的容器对象一般都实现了begin()和end()方法，但是对于基本类型的数组，是没有成员方法的，比如排序一个数组和vector容器对象，数组只能通过计算得到地址(sort函数取地址的范围是 [,) ，即受地址为地一个元素的地址，末地址为最后一个数组内容地址结束之后的下一个地址)：

vector<int> v = { 3, 2, 1 };
int a[] = { 3, 2, 1 };
sort(v.begin(), v.end());
sort(a, a + sizeof(a) / sizeof(a[0]));

在c++11之后，引入了统一的begin()和end()函数，对基本类型同样适用，以上代码在c++11之后可以写成：

vector<int> v = { 3, 2, 1 };
int a[] = { 3, 2, 1 };
sort(begin(v), end(v));
sort(begin(a), end(a));

end(数组名) 输出的内容为数组的最后一个元素的地址的下一个地址。

----


using关键字新功能 >>
c++11为using关键字带来了几个实用的新功能。
在c++中，子类的函数会隐藏父类所有的同名函数，子类的对象是无法调用父类的同名函数的实现的。
在c++11中，在子类的类体中使用 using 父类名::函数名; 可以使子类拥有父类该函数名所有的对应实现，在子类对象中父类的该函数的同名函数不再会被隐藏(类似java中的继承形式)，需要注意的是，使用该方法获得的父类同名函数受到当前类和父类的访问权限限制(如果在protected/private关键字后使用该语句得到的父类函数实现是不能在类外访问/不能访问的，如果父类的同名函数实现是私有/保护的，使用该语句得到的父类实现是不能访问/不能在类外访问的)，但不受继承权限限制(即使是私有继承，也一样能够使用该语句获得父类的同名函数的实现)。
使用 using 父类名::父类名; 可以继承父类的构造函数。

还可以用using关键字来定义类型(类似与typedef，以下两句等价)：

using T = int (*)(int);
typedef int (*T)(int);

using还可以用来定义模板类型：

using T = std::vector<int>;
template <typename T>
class A;
using Test = A<int>;

using还可以部分定义模版类型(typedef没有此功能)：

template <class T>
using Map = std::map<int, T>;

----


统一的初始化方式 >>
在c++11中，可以使用{}初始化各种类型(包括基础类型，对象类型，数组等)，举例：

int a = { 0 };
int b[3] = { 1, 2, 3 };
std::vector<int> v = { 1, 2, 3, 4 };

现在还可以写成(省略等号的形式)：

int a { 0 };
int b[3] { 1, 2, 3 };
std::vector<int> v { 1, 2, 3, 4 };

----


默认或禁用构造函数 >>
当我们定义了自己的带参数的构造函数时，编译器将不再生成默认的构造函数，如果此时想使用默认的构造函数，则必须显式地声明并定义不带参数的构造函数。在c++11中，我们可以使用default关键字来表明我们希望使用默认的构造函数。类似的，当我们不想外部使用编译器自动生成的构造函数或赋值函数时，我们一般需要将其声明成protected或private的。在c++11中，我们可以使用delete关键字来表明我们不希望编译器生成默认的构造函数或赋值函数。示例代码如下：

class A
{
public:
	A() = default;
	A(const A&) = delete;
};

----


强类型枚举 >>
在c++03中，枚举类型不是类型安全的。枚举类型被视为整数，这使得两种不同的枚举类型之间可以进行比较。c++03唯一提供的安全机制就是一个整数或一个枚举型值不能隐式转换为另一个枚举型值。
在c++11中，引入了enum class来声明类型安全的枚举类型。比如：

enum class IColor1 { Red, Blue, Gree=100, Black };

IColor1不能隐式地转换为整数类型，也不能与整数类型比较大小。使用枚举名时，必须明确指定其所属范围，比如：必须使用IColor1::Red，而不能单独使用Red。
在c++11中，使用enum class和传统的enum时，还可以指定其所用的数据类型，不指定时默认为int。比如：

enum class IColor2 : unsigned int { Red, Blue, Gree=100, Black };
enum IColor3 : unsigned int { Red, Blue, Gree=100, Black };

另外，在C++ 03中，无法对枚举类型进行前置声明。而在C++ 11中，只要是使用了指定数据类型的新式枚举，都可以进行前置声明。比如：

enum class IColor1;
enum class IColor2 : unsigned int;
enum IColor3 : unsigned int;

----


偏函数 >>
c++11之后可以使用std::bind()函数来生成偏函数，举例：

#include <functional>
#include <iostream>

using namespace std;

int gets(int, int)
{
	return 0;
}

int main(void)
{
	function<int(int)> p = bind((int (*)(int, int))gets, placeholders::_1, 2);
	cout << p(0) << endl;
	return 0;
}

其中，std::function的模板中填写的是生成的偏函数的函数返回类型及参数表，std::bind()函数的第一个参数填写的是函数名(函数地址)，如果有函数重载，则需要将函数指针显式地按照目标函数的原型进行强制类型转换， placeholders::_1 表示的是参数占位符(数字可以修改，分别为对应位置)。
std::bind()也可以用于绑定类的成员函数，绑定成员函数时，第二个参数需要为成员函数所在类的实例、对象指针或是智能指针。

----


其它新功能 >>
类中的非静态成员变量可以直接在类中赋初值(类似与java)，但是需要注意的是，一个类内部的静态成员变量依然不支持类内初始化(需要在全局区域或是main函数中初始化，初始化时变量类型不能省略)，依旧是常静态成员(const static)才能进行类内初始化(这个不是新特性，c++98就有)。
在c++03中，并非任意的数据类型都能做为union的成员。比方说，带有non-trivial构造函数的类型就不能是 union的成员。在c++11中，移除了所有对union的使用限制，除了其成员仍然不能是引用类型这种情况。
c++11中引入了关键字final，放在类名或函数名之后，用于定义不可继承的类或是不可重写的虚函数。
c++11中引入了关键字override，放在函数名之后，用于显式定义重写函数，拥有该关键字的函数如果未发生重写行为编译器将会报错。

----
