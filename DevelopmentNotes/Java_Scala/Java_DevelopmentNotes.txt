关于Java中的集合类型 >>
与常见的编程语言相同，java中的常见集合类型为List、Set、Map。
List特点：元素有放入顺序，元素可重复。
Map特点：元素按键值对存储，无放入顺序。
Set特点：元素无放入顺序，元素不可重复(注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的)。

在Java中，这三种集合类型都是以接口形式存在的，不能直接使用，要使用这三种类型可以使用其实现类：
List的实现类为LinkedList，ArrayList，Vector；
Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet；
Map接口有三个实现类：HashMap，HashTable，LinkeHashMap；

这些实现类各有优缺点：
ArrayList是非线程安全的，效率高；Vector是基于线程安全的，效率低 。
HashMap非线程安全，高效，支持null；HashTable线程安全，低效，不支持null 。

语法：
List<Type> list = new ArrayList<Type>();
list.add(type);
Map<Key, Type>  map = new HashMap<Key, Type>();
map.put(key, type);

Java支持泛型<>菱形推断，实例化时类型可以省略(Java1.7新特性)，上面的语句实例化可以简写为：
List<Type> list = new ArrayList<>();
Map map = new HashMap<>();
甚至，你还可以直接省略<>符号，完全让编译器推断(Java1.8新特性，一般编译器会隐式推断为Object类型)：
List list = new ArrayList();
Map map = new HashMap();

Set和List都可以得到一个迭代器用于迭代：
Iterator iteratorList = list.iterator();
Iterator iteratorSet = set.iterator();

Map的Key就是一个Set，可以得到Key的集合再迭代：
Set set = map.keySet();
Iterator iteratorSet = set.iterator();

Map使用get(key)可以得到对应的键值，但是这个键值是Object型的，需要通过向下转型来恢复键值类型。
HashMap之类的容器只能一个键对应一个键值，如果需要一个键绑定多个键值可以使用IdentityHashMap。

========


关于泛型方法 >>
Java中的泛型同样支持独立于类的泛型方法，与C++/C#等语言不通，Java在泛型方法中的类型声明放在方法的修饰符(public,static,final,abstract等)之后，返回值声明之前。
Java中的泛型不需要也不支持使用"<>"符号显式指定泛型类型，在泛型方法中输入内容JVM会自动进行类型推倒。

示例代码：

public class Test {
	public static void main(String[] args) {
		Func t = new Func();
		System.out.println(t.getType(123));
		System.out.println(t.getType("Test"));
		System.out.println(t.getType(25.672));
	}
}

class Func {
	public <T> T getType(T t) {
		return t;
	}
}

输出结果：(Windows 10 && JDK 1.8)
123
Test
25.672

========


关于final关键字 >>
Java中有类似C/C++的const关键字的final关键字，final关键字用于定义不可修改的变量，变量加上此关键字之后只能在构造函数或是定义时被初始化。
final还可以用在类之前代表该类不可被继承，也可以用在方法前表示该方法不可被重写。

========


与Access数据库交互 >>
JDK 1.7之前，可以使用JDBC-ODBC桥接Access数据库，但在JAVA8之后，JDBC-ODBC桥被移除，只能使用专有的Access驱动来连接Access数据库(驱动名称：Access_JDBC40.jar)。

----

连接Access数据库的一般步骤 >
String connectUrl = "jdbc:Access:///***.accdb";					//这样写是相对路径
//String connectUrl = "jdbc:Access:///c:/a/b/***.accdb";		//这样写是绝对路径
Class.forName("com.hxtt.sql.access.AccessDriver");
connection = DriverManager.getConnection(connectUrl);
statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);			//后面的两个参数是为了得到resultSet集能够进行last()操作

----

Access数据库的一些小常识 >
1.表单的高级字段设置在"开始 - 视图 - 设计视图"中。
2.配置自增属性需要将字段类型设为"自动编号"。
3.默认情况下，创建的数据类型"数字"的字段大小为"长整型"，这是不支持小数输入的，小数输入会自动被去尾，需要将字段大小设置为"单精度浮点型/双精度浮点型"才能支持小数位。
4.如果需要某个字段的内容唯一不可重复，可以将改字段的索引设置为"有(无重复)"即可。

========


Eclipse小技巧 >
Eclipse是Java开发中最常用的IDE，Eclipse通过插件扩展可以进行多种语言的开发。

----

在Eclipse中查看JDK类源码 >
与NetBeans不同，在Eclipse中默认是无法直接查看JDK中类库的源码的，需要手动指定源码的位置。
一般情况下，JDK源码位于JDK的安装目录下的"src.zip"文件中。
在Eclipse中按以下步骤添加源码路径：
Window => Preferences => Java => Installed JREs => 选中使用的JRE => Edit => 选中../xxx/rt.jar => Source Attachment Configuration => Exernal location => 选中src.zip => OK => Finish

----

设置Eclipse编辑器自动换行 >
Eclipse的编辑器没有自动换行的功能，该功能需要通过第三方插件进行实现。
在Eclipse中按以下步骤安装 "Word Wrap" 插件使编辑器能够自动换行：
Help => Install New Software => Add Repository => 输入仓库地址 http://ahtik.com/eclipse-update => 安装WordWrap插件 => 安装完成之后重启IDE => 编辑器中点右键，激活 "Word Warp" 选项 => Finish

========


关于Java中package和import关键字的使用 >>
在Java中，没有使用package的话，在javac编译java文件生成class字节码时，需要将所有用到的源码文件写在参数中，不在当前目录下的源码文件要写清路径。
如果源码文件过多，则可以使用package关键字将其打包归类，然后在主类所在的文件中使用import关键字来将包导入使用。
如果没有使用package关键字，则所有的内容被视为在一个包中。

----

import的基本用法 >
import的格式是：
import [包名].[类名]
如果需要包含内部类，则可以使用多级import，如：
import [包名].[类名].[类名]....
需要注意的是，import与代码文件的路径无关(但运行class文件时需要将class文件放在与其源码中package名称相同的对应目录下，否则会在执行时出错)。
另外，包名也可以是*.*.*的形式。

----

使用静态导入 >
Java 1.5中新加入了import static关键字，相比传统的import，import static关键字的包含目标是类中的静态方法，格式如下：
import static [包名].[类名].[类名]....[静态方法名]
这样能够在使用对应类的静态方法时不必写出类名而是直接写出函数名即可。

----

package使用实例 >
有两个文件A.java和B.java。
文件B中的类被A中引用,则将B打包,代码中添加 package b，并放在b目录下。
而文件A中引用B中的类。
按照要求，两文件的位置：
文件A路径为~/A.java。
文件B路径为~/b/B.java。

实例代码(普通import)：

A.java:

import b.B;

public class A {
	public static void main(String[] args) {
		B.getNow();
	}
}


B.java:

package b;

public class B {
	public static void getNow() {
		System.out.println("Success!");
	}
}

实例代码(import static)：

A.java:

import static b.B.getNow;

public class A {
	public static void main(String[] args) {
		getNow();
	}
}

B.java:

package b;

public class B {
	public static void getNow() {
		System.out.println("Success!");
	}
}

其中A.java文件能够正常调用类B的方法getNow()。
一个java文件只能有一个public类，java文件的名称应该与那个public类的类名一致。
需要注意的是，package打包的文件最好放在与包名相同的文件夹中，这样生成的字节码class文件才会在对应目录生成。如果源码是放在一处的，则编译之后产生的字节码文件需要按照package关系放在与包名相同的目录下，否则执行class文件时会报错，显示找不到对应的class文件！

----

使用第三方jar包的编译/运行方式 >
很多时候，我们需要使用java官方库之外的第三方库(jar文件)，编译时需要添加额外的参数。
假设代码中引用了一个第三方库，则编译时应使用-cp参数，如下：
$ javac -cp [第三方库的路径] [源码文件]
编译生成的class文件是无法直接被java指令执行的，因为该class文件使用了第三方库，而这个库的位置并不在系统的环境变量之中，因此运行也需要显式地指定所需库的位置：
$ java -Djava.ext.dirs=[第三方库所在的目录] [编译生成的class文件]


========


Swing开发小知识点 >>

设置边框 >
一般的GUI容器类如JFrame、JPanel等都可以通过setBorder()方法来设置边框。
特别的，通过使用透明边框，可以实现控制界面边界空隙的效果(类似于WEB开发中的Margin属性)。
举例：
setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));				//界面上下左右空出10个像素

----

常见的一些控件 >
容器：
JFrame(框架)
JDialog(对话框，比JFrame消耗资源少)
JPanel(面板)
JScrollPane(滚动面板)
JFrame一般做为顶层容器，可以独立做为对话框显示，但JPanel不能独立做为对话框。
文本组件：
JLabel(显示文本)
JTextField(单行编辑框)
JPasswordField(密码编辑框)
JTextArea(多行编辑区域)
表单组件：
JButton
JCheckBox(复选框，方框里打勾)
JRadioButton和ButtonGroup(单选框，圆点)
JComboBox(组合框，俗称下拉列表框)
菜单栏：
JMenubar(菜单栏)
JMenu(菜单栏上的按钮)
JMenuItem(点击菜单按钮弹出的菜单项)
常用的表单组件都有对应的菜单版本，比如JRadioButtonMenuItem、JCheckBoxMenuItem等。
向JMenu中add()菜单项时，虽然可以选择普通组件，但普通组件不能触发菜单效果(点按之后菜单不收回)。

----

利用Map的Key来作为ComoBox的下拉选项 >
先得到map的Key集合：
Set set = map.keySet();
接着将集合转化为对象数组：
Object[] object = set.toArray();
接着构造一个用对象数组初始化的DefaultComboBoxModel对象，并以此构建JComoBox对象：
JComboBox comboBox = new JComboBox(new DefaultComboBoxModel(object));

----

Java事件机制 >
Java的事件机制是通过监听器实现的。
要处理GUI事件，先要根据需求实现事件接口，比如点按事件的ActionListener，处理键盘的KeyListener，处理鼠标的MouseListener等等。
然后在要被监听的的GUI控件上调用对应的addXXXListener()方法将接口实例化的对象作为参数传入即可。

----

在键盘事件中屏蔽指定按键 >
实现KeyListener接口，重写keyTyped(KeyEvent)方法，通过getKeyChar()方法获取输入的字符，然后对其进行判断，如果是想要屏蔽的按键则使用setKeyChar('\0')将其转化为空输入。

举例：(只接受数字输入)
KeyEvent keyEvent = (e) -> {
	if ((e.getKeyChar() < '0' || e.getKeyChar() > '9'))
		e.setKeyChar('\0');
}

----

文本输入监听器DocumentListener >
包含三个方法：
public void changedUpdate(DocumentEvent e)：监听文本属性的变化；
public void insertUpdate(DocumentEvent e)：监听文本内容的插入事件；
public void removeUpdate(DocumentEvent e)：监听文本内容的删除事件。
需要注意的是JTextField控件本身没有addDocumentListener()方法，需要先使用getDocument()方法获取Document对象才能调用addDocumentListener()。
在事件处理方法中，对JTextField对象调用getText()方法即可获得输入文本的内容。

----

显示多行文本 >
JTextField只能用来显示简单的单行文本，涉及到多行文本的复杂情况，需要使用到JTextArea控件：
JTextArea textArea = new JTextArea();
可以设置文本域自动换行：
textArea.setLineWrap(true);
当文本域内容太多无法全部显示时，可以使用JScrollPane控件，将文本域添加到其中：
JScrollPane scrollPane = new JScrollPane(textArea);
这样当文本无法全部显示时会出现滚动条。

----

静态MessageBox方法 >
与Qt一样，Java也提供了弹出MessageBox的静态方法，即JOptionPane.showMessageDialog。
static void showMessageDialog(Component parentComponent, Object message) 									//调出标题为 "Message" 的信息消息对话框。
static void showMessageDialog(Component parentComponent, Object message, String title, int messageType) 				//调出对话框，它显示使用由 messageType 参数确定的默认图标的 message。
static void showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon) 						//调出一个显示信息的对话框，为其指定了所有参数。
其中，messageType可以取DEFAULT_OPTION、YES_NO_OPTION、YES_NO_CANCEL_OPTION 或 OK_CANCEL_OPTION等。
此外，还有showInputDialog、showConfirmDialog等方法可以用于显示其他用途的窗口。

----

使用JTable显示数据库 >
构建一个JTable主要有两种方式：
JTable(Object[][] rowData, Object[] columnNames);
JTable(TableModel dm);
即使用Object数组确定表格模型或是使用TableModel类构建表格模型。
使用对象数组构建表格模型可以先从数组库中读取对应数据，然后将数据存储在对象数组中。
使用TableModel类可以先构建TableMode对象，然后使用TableMode类的成员方法setValueAt(Object aValue, int rowIndex, int columnIndex)设定表格模型每个位置的数据，最后在JTable使用构造函数或在已有的JTable对象调用setModel(TableModel dataModel)成员方法创建表格。
