Scala开发环境 >>
在Linux/Unix环境下，无需额外的Scala配置，只需从对应发行版的包管理器中直接安装Scala开发包即可。
在Windows环境下，需要新建环境变量"SCALA_HOME"，环境变量的值即为Scala的安装目录，然后将"%SCALA_HOME%\bin"加入PATH环境变量中。

----

让VIM支持Scala语法高亮 >
在bash中输入以下脚本指令：
$ mkdir -p ~/.vim/{ftdetect,indent,syntax} && for d in ftdetect indent syntax ; do wget --no-check-certificate -O ~/.vim/$d/scala.vim https://raw.githubusercontent.com/derekwyatt/vim-scala/master/syntax/scala.vim; done'
如果使用Vundle来管理插件，则可以在配置文件中添加：
Plugin 'derekwyatt/vim-scala'

----

让Eclipse支持Scala项目 >
安装Scala IDE插件即可。

----

编译/执行Scala代码 >
与编译Java代码类似，编译Scala代码使用scalac命令：
$ scalac [*.scala]
编译后即可得到字节码文件*.class。
执行字节码可以使用scala指令：
$ scala [主类名]
对于使用了包(package)的源码，在用scalac指令进行编译时，编译器会自动根据包路径创建对应的目录，然后在对应的包路径下生成对应的class文件。
运行带有包路径的字节码需要在包路径的相对根目录下，执行：
$ scala [包路径].[主类名]
需要注意的是，虽然Scala是基于JVM的语言，但scalac编译得到的字节码直接由java命令执行会出现一些错误。
此外，虽然Scala并不强制要求类名要与文件名相同，但在部分IDE中，如果类名与文件名不同，构建项目会出现错误。

----

使用Scala解释器 >
在命令行中输入无参数的scala指令即可进入交互式的Scala解释器。
Scala解释器与Python解释器类似，可以直接将代码一行行地输入解释器，解释器会执行代码并给出反馈，对初学者而言是一个练习的好方法。

常用的Scala解释器指令：
scala> :quit				//退出解释器
scala> :reset				//重置解释器的状态，会清空已保存的变量、类、方法等所有内容

========


Scala基本语言特性 >>
相比Java、C++等语言，Scala融合了OOP、FP等编程范式，同时语法上更灵活。

----

语法基础(概览) >
1.Scala语言中不强制要求分号，可以依行断句，只有一行带有多个语句时才要求分号隔开。
2.使用var/val定义变量/常量，类型可以由编译器推导，也可以显式指定。定义变量时甚至可以省略var/val关键字，无关键字时定义的变量默认即为val，在定义变量的同时就需要初始化变量，否则报错(抽象类中除外)。
3.使用def关键字定义方法，var/val定义函数，需要注意的是使用var定义的函数是可以更改实现的，但def定义的方法一经定义实现就不可改变。
4.没有自增/自减操作符。
5.所有类型皆为对象，基础类型如Int、Double等都是类，函数/方法返回值的空类型为Unit，相当于Java/C++中的void。
6.没有原生enum类型，应继承枚举助手类Enumeration。
7.不提供类似Java/C++中的三目运算符，但if语句表达式带有返回值，可以提供类似效果。
8.访问类成员权限默认为public，因而没有public关键字，但有private和protected关键字，作用与Java大致相同，但支持更细粒度的权限控制。
9.支持函数重载，可以使用操作符作为函数名，达到类似C++/C#中操作符重载的效果。
10.类的成员变量可以与方法名称相同。

----

Hello World >
创建文件 Test.scala ，输入以下代码：

object Test {
	def main(args: Array[String]): Unit		//带有等号的方法可以省略返回值类型由编译器进行推导
		= println("Hello World!")
}

与Java类似，Scala也是从主方法main中开始执行整个程序，不过main方法并不定义在类中，而是定义在单例对象中(使用object关键字创建单例对象)。
将主方法写在class中能够通过编译，但生成的字节码文件在执行时会出错。
也可以不手动定义main方法而去让伴生对象继承App特质，即可直接执行代码语句，例如：

object Test extends App {
	println("Hello World!")
}

单例对象的名称可以与源码文件的文件名不同。

----

方法(Method) >
与Java不同，Scala中同时支持函数与方法(Java只有方法而没有真正意义上的"函数"，只有与"函数"类似的"静态方法")。
方法由def关键字定义，可以被def方法、val函数重写。一个典型的方法格式如下：

def methodName(args: Type)：Type = {
	/* function_body */
}

Scala中方法体不需要显式使用return关键字来给出方法返回值，编译器会将函数体的最后一句代码推导出类型做为整个函数的返回值。
对于有返回值的方法，必须要在方法定义中加入等号，否则编译器不会对推导返回值。
即使方法的返回值为Unit，只要显式指定了返回值类型，则必须在方法体中加入等号。
方法和函数的形参不需要也不能使用val/var关键字声明，只需写明类型即可。
在Scala中，方法允许省略参数，空的参数表可以直接省略，如：
def getNum: Int = 100
def getNum(): Int = 100					//以上两个定义作用相同，但只能存在一个

无参方法与空参方法只能存在一个，但二者在使用方式上略有不同，无参方法在调用时只能直接使用方法名，在方法名后加上括号调用就会出错；但空参方法既可以使用带有括号的方法调用方式，也可以省略括号，例如：
scala> def getNum: Int = 100			//定义了方法 getNum: Int
getNum: Int
scala> getNum							//正确，返回 100
res0: Int = 100
scala> getNum()							//错误，提示 error: Int does not take parameters
<console>:12: error: Int does not take parameters
	getNum()
		  ^
scala> def getNum(): Int = 200			//定义了方法 getNum(): Int
getNum: ()Int
scala> getNum							//正确，返回 200
res1: Int = 200
scala> getNum()							//正确，返回 200
res2: Int = 200
同时，无参方法不能与已有字段名称相同(编译报错)，而空参方法允许带有同名的字段。

在Scala中，方法中参数允许带有默认值：
scala> var num = 100
num: Int = 100
scala> def setNum(p: Int = 0) { num = p }		//方法/函数的参数不能由默认值进行类型推导，即使给参数写明了默认值，也依然需要显式指明类型
setNum: (p: Int)Unit
scala> setNum()				//对于有参数的方法，即使参数带有默认值使得参数表可以为空但在调用时依然不能省略括号，否则报错
scala> println(num)
0							//输出0

需要注意的是，在Scala中，赋值表达式的值为Unit，而不是类似Java/C++中的以被赋值的变量类型为表达式的值。例如：
scala> var _num = 0
_num: Int = 0
scala> def testNum(num: Int): Int = _num = num		//由编译器推断出的返回值类型为Unit
<console>:12: error: type mismatch;
found   : Unit
required: Int
	def testNum(num: Int): Int = _num = num
									  ^

----

函数(Function) >
在Scala中函数使用var/val关键字定义，即函数是一个存储了函数对象的字段。
一个典型的函数定义如下：

var functionName: FuncType = 符合签名的方法/函数/Lambda

需要注意的是，函数不允许无参，因为函数名做为表达式时的语义为函数名所代表的函数内容而非函数调用。空参函数的括号不可省略，直接使用函数名并不代表调用空参函数，比如：
scala> var show100: () => Int = () => 100
show100: () => Int = <function0>
scala> show100				//直接使用函数名得到的是函数对象而非调用函数
res0: () => Int = <function0>
scala> show100()
res1: Int = 100

----

方法作为参数 >
Scala味函数式编程语言，在Scala中方法可以直接作为参数传递。
当方法作为参数存在时，若其它参数相同，同样位置的无参方法与空参方法参数只能存在一个，如下定义只能存在一个：

def func(arg: () => Unit) = arg
def func(arg: => Unit) = arg
var func: (() => Unit) => Unit = (arg: () => Unit) => arg

在接收参数时，空参方法参数只能接收无参方法，无参方法参数既能接收无参方法，也可接受空参方法和空参函数。

========


类型系统 >>
在Scala中，所有的类型皆为对象，所有类型都从根类Any继承，Any有AnyVal和AnyRef两个子类。
在Scala中，基础类型如Int、Float、Double、Unit等全部从AnyVal类中派生，因而可以直接在泛型中直接使用这些类作为类型参数。
同时，Scala中提供了隐式转换(ImplicitConversion)来保证Int/Float/Double等类型之间可以自动进行转换。
基础类型与字符串(String)等类型之间的转换也由类提供的成员函数进行，如将数值与字符串相互转换可以使用如下代码：
var str = 100.toString
var num = str.toInt
在Scala中，所有的基础类型之外的引用类型派生自类AnyRef。

----

底类型(Bottom) >
与Java不同，Scala中存在底类型(bottom)。底类型包括Nothing和Null，Nothing是所有类型的子类，Null是所有引用类型(AnyRef)的子类，Nothing类没有值，Null类只有一个值null(类似于Java中null的作用)。

---

可空类型 >
在Scala中，使用Option[T]表示可空类型，Option[T]包含两个子类，Some[T]和None，分别代表值存在/值为空。
对Option[T]类型使用getOrElse()方法来获取存在的值或是当值不存在时使用指定的值，如下所示：
scala> var str1: Option[String] = "test"
<console>:10: error: type mismatch;			//赋值失败，Option[T]只能接收Option及其子类
found   : String("test")
required: Option[String]
	var str1: Option[String] = "test"
							   ^
scala> var str1: Option[String] = Option("test")
str1: Option[String] = Some(test)
scala> var str2: Option[String] = None
str2: Option[String] = None
scala> println(str1 getOrElse "Get Value Failed!")
test
scala> println(str2 getOrElse "Get Value Failed!")
Get Value Failed!							//输出getOrElse()方法中设定的值

可空类型也可以用于模式匹配中，如下代码所示：
object TestOption extends App {
	var s  = List(Some(123), None)
	for (num <- s)
		num match {
			case Some(x) => println(x)
			case None => println("No Value")
		}
}

运行结果：
123
No Value

========


Scala中的OOP >>
Scala是一门同时具有函数式与面向对象特性的多重范式的语言，除了具有函数式特性外，对OOP也有着完整的支持。

----

类(class)与特质(trait) >
Scala不支持多重继承，但可以继承多个trait。
Scala中的trait对应Java中的interface，但相比Java中的interface，Scala中的trait除了没有默认构造器之外，拥有绝大部分类的特性。
Scala中的trait可以拥有构造器(非默认)，成员变量以及成员方法，成员方法也可以带有方法的实现，并且trait中的成员同样可以设置访问权限。

----

构造器(Constructor) >
在Scala中构造方法的作用与Java类似，用于在创建类实例的同时对指定的成员进行初始化。
在语法上，Scala中类可以拥有一个主构造器(primary constructor)和任意个辅助构造器(auxiliary constructor)。
主构造器的参数定义紧跟在类名之后，辅助构造器定义在类体中，使用this关键字，在辅助构造器中最终必须调用主构造器。
调用父类的主构造器必须在主构造器中，写在父类类名之后。
需要注意的是，主构造器的参数将成为类的成员，而辅助构造器中的参数则与普通函数参数类似，仅在构造器代码段内部生效。
如下代码所示：

//定义主构造器
class Constructor(a: Int = 1, var b: Double = 2.0) {		//构造器参数紧跟在类名之后，构造器中的参数可以带有默认值
	//在构造器中创建了两个字段，如果没有显式使用var/val关键字创建字段，则创建的字段是当前实例私有切不可变的(private[this] val)

	//定义辅助构造器，使用this关键字
	def this() = this(2, 3.0)		//辅助构造器的函数体中必须最终调用主构造器，辅助构造器即使没有参数也必须也必须带括号
}

//只有主构造器能够调用父类构造器
class ExtendConstructor(a: Int = 2, c: Double = 4.0) extends Constructor(a, c) {
	def this() {
		this(2, 4.0)
		//super(2, 4.0)				//在Scala中没有这种用法，父类的构造函数只能由主构造器调用
	}
}

----

访问权限 >
Scala中的成员默认访问权限即为公有，因而Scala中没有public关键字。
Scala中的保护成员和私有成员使用关键字protected/private，作用大体上与Java相同，但Scala在访问权限上支持更细粒度的划分。
在Scala中，访问级别关键字之后可以使用中括号带上更具体的访问区域限制，可以是当前定义的类、当前定义类的外部类(若存在外部类)、包名(某个包内的所有类实例可访问)或是this关键字(仅当前实例可访问)。
访问权限关键字之后若不写明具体的访问限制区域，则默认限制为当前类可访问(与Java行为基本一致，但Java中的保护成员包内可见)。
如下代码所示：

package TestCode ｛

class Access(a: Int = 1, var b: Double = 2.0) {
	def showOther1(access: Access) = access.show1			//出错，access非当前类实例，无访问权限
	def showOther2(access: Access) = access.show2			//正常访问
	def showOther3(access: Access) = access.show3			//正常访问
	private[this] def show1 = println(a + " " + b)			//限定当前实例可访问
	private[Access] def show2 = println(a + " " + b)		//类似Java中的private，当前类的任意实例皆可相互访问私有成员
	private[TestCode] def show3 = println(a + " " + b)		//作用域为包名，此时的访问权限类似Java中的default访问权限，当前包中类的实例皆可访问到该私有成员
}

｝

----

字段 >
Scala类中的字段不仅仅是定义了一个成员变量，编译器还可能会自动为字段生成与字段同名的getter和setter方法。
var关键字定义的字段编译器会同时为其生成setter和getter方法，若对象的的权限为私有/保护，则对应生成的setter和getter方法同样为私有/保护权限。
val关键字定义的字段为只读字断，编译器不会为其合成setter方法。
若访问权限为private[this]，则编译器不会为其合成setter和getter方法(protected[this]正常生成setter/getter方法)。
如下所示：

class Override {

	var m = 100									//普通成员字段会自动合成setter/getter方法
	/*
	def m(): Int = m							//错误，提示重复定义
	def m_=(m: Int) { this.m = m }				//错误，提示重复定义
	*/
	def m(m: Int) {}							//正常，签名未冲突

	private[this] var num = 100					//私有this字段不会合成setter/getter方法，但自行手动定义同名的setter/getter方法时有许多限制(getter方法需要空参且写明返回值)，且没有实用价值(setter方法使用报错)
	def num(): Int = num						//正常
	def num_=(num: Int) { this.num = num }		//正常，虽然定义时不报错，但赋值时报错
	/*
	def num = this.num							//报错
	def num: Int = num							//报错
	def num: Int = this.num						//报错
	*/

	//常用的私有变量自定义setter/getter风格是私有字段名前加上下划线
	private[this] var _abc = 0
	def abc = _abc
	def abc_=(abc: Int): Unit = _abc = abc
	/*
		也可以写成：
		def abc_=(abc: Int) { _abc = abc }
	*/
}

在Scala中，字段名称可以与方法名城相同，默认情况下，合成的setter/getter方法就与字段同名，手动在代码中创建与setter/getter签名相同的方法会导致编译错误，但在访问权限为private[this]时编译器不合成默认的getter/setter方法时可以手动定义setter/getter方法。
需要注意的是，在实际编码过程中，虽然给private[this]的字段定义同名的setter/getter方法不会报错，但实际调用过程中会提示错误(如上例子中给num字段赋值回得到错误"reassignment to val"，因此不要手动给字段定义同名的setter/getter方法)。
此外，由于字段名称可以与方法名称相同，因而即使编译器生成了setter/getter方法，编码者依然可以使用字段名称定义其它签名的重载函数。

----

多态 >
重写：
在Scala中，默认情况下，子类的并不会重写父类的同名方法，而是需要显式地在方法定义前加上override关键字才会发生重写行为。
Scala中的重写遵循以下规则：
1.def只能重写另一个def。
2.var只能重写另一个抽象的var(即只有定义没有实现)。
3.val可以重写另一个val以及不带有参数的def。
重载：
Scala支持函数重载，并且可以使用操作符作为函数名，使用操作符作为函数名可以达到类似C++中操作符重载的效果。

----

继承 >
Scala中的继承采用的是混入(mixin)机制，相比传统的单根继承，mixin机制保留了多重继承的大部分优点，同时又避免了多重继承可能可能引入的菱形继承问题。
对于作用域内可见的字段和方法，

----

伴生对象 >
在Scala中没有static关键字，也没有静态成员的概念，Scala使用单例来达到近似静态成员的作用。
每一个类可以拥有一个同名的伴生对象(单例)，伴生对象使用object关键字定义，且一个类和其伴生对象的定义必须写在同一个文件中。

----

apply()/update()方法 >
在Scala中，允许使用函数风格进行一些对象操作。
假设有一个类实例a，使用：
a(arg1, arg2, arg3, ...)
此表达式等价于：
a.apply(arg1, arg2, arg3, ...)
同样的，使用：
a(arg1, arg2, arg3, ...) = value
等价于：
a.update(arg1, arg2, arg3, ..., value)
如下代码所示：

object Main extends App {
	var a = new Apply(0, 0)
	val show = () => println(a.num1 + " " + a.num2)
	a(1)								//相当于调用 a.apply(1)
	show()								//输出 1 2
	a(100, 200) = Apply(10, 20)			//相当于调用 a.update(100, 200, new Apply(10, 20))
	show()								//输出 90 180
	Apply(1000, 2000) = a
	show()								//输出 1000 2000
}

class Apply(var num1: Int, var num2: Int) {
	def apply(num: Int) {
		this.num1 = num
		this.num2 = num + 1
	}
	def update(num1: Int, num2: Int, test: Apply) {
		this.num1 = num1 - test.num1
		this.num2 = num2 - test.num2
	}
}

object Apply {
	def apply(num1: Int, num2: Int) = new Apply(num1, num2)
	def update(num1: Int, num2: Int, test: Apply) {
		test.num1 = num1
		test.num2 = num2
	}			//伴生对象同样可以拥有apply()/update()方法
}

输出结果：
1 2
90 180
1000 180

----

提取器 >
在Scala中，还提供了被称为"提取器"的unapply()方法。
unapply()方法则与apply()方法相反，可以从对象中提取出需要的数据(在实际使用过程中，可以从任意的目标里提取数据)。
unapply()方法返回值必须为Option，单一返回值使用Option[T]，多个返回值可以包含在元组中Option[(T1, T2, T3, ...)]。
unapply()方法虽然也可以定义在类中，但一般在伴生对象中使用(在类中定义没有合适的语法使用)。
假设有伴生对象名为Unapply，则：
var Unapply(arg1, arg2, arg3, ...) = value
等价于：
var (arg1, arg2, arg3, ...) = Unapply.unapply(value)
如下代码所示：

object TestUnapply extends App {
	var Unapply(num1) = 1							//提取一个值
	println(num1)
	var Unapply(num2, num3) = Unapply(100, 200)		//提取多个值
	println(num2 + " " + num3)
}

object Unapply {
	def apply(num1: Int, num2: Int) = new Unapply(num1, num2)
	def unapply(num: Int) = Option(num)
	def unapply(a: Unapply) = Option((a.num1, a.num2))
}

class Unapply(var num1: Int, var num2: Int) {
}

输出结果：
1
100 200

若需要提取任意长度的值的序列，则可以使用unapplySeq()方法，该方法返回值类型为Option[Seq[T]]。
不要同时定义unapplySeq()方法和unapply()方法，会产生冲突。
如下代码所示：

object TestUnapply extends App {
	def showSplit(str: String) = str match {
		case Unapply(str1, str2) => println(s"$str1 $str2")
		case Unapply(str1, str2, str3) => println(s"$str1 $str2 $str3")
		case _ => println("Case Nothing")
	}
	showSplit("abc")
	showSplit("abc.cde")
	showSplit("abc.cde.efg")
}

object Unapply {
	def unapplySeq(str: String) = Option(str split "\\.")		//split()方法接收的是正则表达式，小数点、加减乘除之类的符号需要转义
}

输出结果：
Case Nothing
abc cde
abc cde efg

----

使用匿名类初始化 >
在Scala中，创建类实例的同时可以直接对类的成员变量进行初始化。
如下代码所示：

object Init extends App {
	var num = new Num {
		num = 100
		name = "Num"
	}		//相当于创建了一个匿名类，然后向上转型到类Num上
	println(num.name + " " + num.num)		//正常输出了初始化的值
}

class Num {
	var num: Int = 0
	var name: String = ""
}

以上代码用Java改写为：

class Init {
	public static void main(String[] args) {
		Num num = new Num() {{
			num = 100;
			name = "Num";
		}};		//匿名类的构造函数的函数名为空，因此可以使用大括号直接嵌套的方式
		System.out.println(num.name + " " + num.num);
	}
}

class Num {
	int num = 0;
	String name = "";
}

输出结果：
Num 100

========


枚举(Enumerate) >>
在Scala中，没有语言级别的枚举类型，枚举的功能可以通过继承枚举类Enumeration实现。

----

继承枚举类 >
继承枚举类Enumeration可以在成员中使用无参方法Value给每个枚举成员赋值。
默认的Value方法会按变量名生成枚举名和并从0开始生成枚举ID，若需要手动设定枚举的名称喝枚举ID则可以使用Value方法的重载(Value(id: Int, name: Strig))
如下代码所示：

object Color extends Enumeration {
	var red, green, blue = Value

	/*
	* 相当于分别初始化：
	* var red = Value
	* var green = Value
	* var blue = Value
	*/

	//手动使用Value(id: Int, name: String)方法手动进行id和name的设置
	var white = Value(100, "_white_")
	var black = Value(200, "_black_")
	//使用重载有參版本的Value(id: Int, name: String)不能采用自动赋值的方式，会编译报错
}

object TestEnumeration extends App {
	println(Color.red.toString + ":" + Color.red.id + " " + Color.green + ":"
		+ Color.green.id + " " + Color.blue + ":" + Color.blue.id)
	println(Color.white + ":" + Color.white.id + " " + Color.black + ":" + Color.black.id)
}

输出结果：
red:0 green:1 blue:2
_white_:100 _black_:200

========


数组 >>
Scala中数组的概念与Java中基本类似。

----

定长数组 >
在Scala中定长数组使用Array[T]进行表示，定长数组与Java中概念类似。
构建一个固定长度的数组如下所示：
scala> var array = new Array[Int](10)			//构建一个长度为10的Int型数组
array: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
scala> var a = Array(100, 200)					//使用伴生对象的apply()方法创建数组
a: Array[Int] = Array(100, 200)
scala> array(5)									//获取数组中指定位置的值(使用小括号中加偏移量)
res1: Int = 0
scala> array(5) = 10							//给指定位置的元素赋值
scala> array									//查看赋值结果
res2: Array[Int] = Array(0, 0, 0, 0, 0, 10, 0, 0, 0, 0)
scala> array(100)								//数组访问越界会抛出异常
java.lang.ArrayIndexOutOfBoundsException: 100
  ... 33 elided
需要注意的是，Scala定长数组与Java中的定长数组仅仅是语法不同，并无本质区别，"new Array[Int](10)"相当于Java中的"new int[10]"。

----

变长数组 >
在Scala中，变长数组使用ArrayBuffer[T]进行表示，ArrayBuffer不在默认导入的包路径中，而是位于scala.collection.mutable.ArrayBuffer。
Scala中的ArrayBuffer相当于Java中的ArrayList，可存储任意数量的元素，创建一个ArrayBuffer：
scala> var arrayBuffer = new ArrayBuffer[Int]
arrayBuffer: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()
var a = ArrayBuffer(100, 200)					//同样可以使用伴生对象的apply()方法创建ArrayBuffer
a: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(100, 200)
ArrayBuffer可以使用"+="和"-="进行增加与删除元素：
scala> arrayBuffer += 10
res10: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10)
scala> arrayBuffer += 100
res11: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 100)
scala> arrayBuffer += 1000
res12: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 100, 1000)
scala> arrayBuffer -= 1000
res13: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 100)
需要注意的是，"+=""-="只是方法名并不是运算符，因此，以下的写法会报错：
arrayBuffer = arrayBuffer + 10
<console>:12: error: type mismatch;
found : Int(10)
required: String
	arrayBuffer = arrayBuffer + 10
								^
与Java中的ArrayList类似，ArrayBuffer也允许在任意位置进行元素插入：
scala> arrayBuffer.insert(1, -100)					//在索引1的位置插入数值-100
scala> arrayBuffer
res17: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, -100, 100)
插入多个元素：
scala> arrayBuffer.insert(1, 7, 8, 9)				//在索引1的位置插入数值7，8，9
scala> arrayBuffer
res19: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 7, 8, 9, -100, 100)
删除操作类似，移除操作可以指定首位进行批量移除：
scala> arrayBuffer.remove(1, 4)
scala> arrayBuffer
res21: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer(10, 100)		//删除了索引1到4位之间的元素
需要注意的是，ArrayBuffer是线性结构，只有在尾部进行插入删除操作才是高效的，在其它位置进行的元素操作都会造成大量的元素移动。

========


容器 >>
Scala的容器分为元组(Tuple)、序列(Seq)、集合(Set)和映射(Map)四大类。

----

元组(Tuple) >
元组是最简单的容器，无需额外的类型名称，直接使用"(T1, T2, T3)"就可以构建出一个元祖。如下所示：
scala> var tuple = (1, 2, 3)
tuple: (Int, Int, Int) = (1,2,3)
元组中允许包含重复的值，也允许不同类型的值。
元组可以通过"元组对象._索引号"的形式访问，不过元组是从1开始而非0，如下所示：
scala> println(tuple._1 + " " + tuple._2 + " " + tuple._3)
1 2 3
元组可以用来一次性初始化多个变量：
scala> var (a, b, c) = tuple			//等价于 var (a, b, c) = (1, 2, 3)
a: Int = 1
b: Int = 2
c: Int = 3
scala> println(s"$a $b $c")
1 2 3
元组可以包含不同的类型：
scala> var (num, str) = (123, "456")
num: Int = 123
str: String = 456
元组用作函数返回类型时，即可让一个函数拥有多个返回值，如下所示：

object TestTuple extends App {
	def getNum(num1: Int, num2: Int, num3: Int) = (num1, num2, num3)
	var (num1, num2, num3) = getNum(1, 2, 3)
	println(s"$num1 $num2 $num3")
}

输出结果：
1 2 3

需要注意的是，元组不能够使用for循环进行遍历。

----

列表(List)与可变列表(LinkedList) >
在Scala中，List[T]类型的完整路径为scala.collection.immmutable.List。
List为不可变对象，可以使用for循环进行遍历。
构建一个列表：
scala> var list0 = List(1, 2, 3)
list0: List[Int] = List(1, 2, 3)
除了直接使用List类型提供的apply()方法构建列表对象之外，还可以使用"::"操作符来将多个值构成列表，使用操作符构成列表时需要注意，列表的最后一个值必须为Nil，如下所示：
scala> var list1 = 0 :: 1 :: 2 :: 3 :: Nil
list1: List[Int] = List(0, 1, 2, 3)
列表同样允许不同类型的值，也允许重复的值，如下所示：
scala> var list2 = 1 :: 1 :: "str" :: 2.0 :: Nil
list2: List[Any] = List(1, 1, str, 2.0)
只不过，若列表中存储的若是相同的类型，则编译器会将List[T]推导为具体的类型，若列表中成员类型各不相同，则编译器会使用所有类型的基类Any作为泛型类型及List[Any]。
列表支持从已有的列表进行创建：
scala> var list0 = 1 :: 2 :: 3 :: Nil
list0: List[Int] = List(1, 2, 3)
scala> var list1 = 0 :: list0				//向列表头部增加元素
list1: List[Int] = List(0, 1, 2, 3)
scala> var list2 = list0 :: 4				//列表是不能从尾部创建(List以Nil结尾)
<console>:11: error: value :: is not a member of Int
	var list2 = list0 :: 4
					  ^
使用":::"运算符可以叠加两个列表：
scala> var list2 = list0 ::: list1
list2: List[Int] = List(1, 2, 3, 0, 1, 2, 3)
也可以使用"++"运算符连接两个列表：
scala> var list3 = list0 ++ list1
list3: List[Int] = List(1, 2, 3, 0, 1, 2, 3)
":::"与"++"对于列表而言，作用完全相同，只不过":::"是List类型特有的运算符，而"++"继承于特质TraversableLike，也可用于一些其它的集合类型。
列表同样支持通过索引进行访问，语法与Array[T]类型类似：
scala> list0(0)
res0: Int = 1

在Scala中，同样支持可变列表类型。
可变列表scala.collection.mutable.LinkedList在现在的版本中(2.11.7)已被标记为废弃的。
当前版本可以使用scala.collection.mutable.ListBuffer为可变列表。
ListBuffer[T]类的常规操作如下所示：

object TestList extends App {
	import scala.collection.mutable._
	val show: ListBuffer[Any] => Unit = for (s <- _) print(s"$s ")
	var listBuffer = ListBuffer(1, "str", 2.0)
	listBuffer remove 0					//移除指定索引位置的值
	show(listBuffer)
	println
	listBuffer += "num"					//添加新值
	show(listBuffer)
	println
	listBuffer update (2, "new")		//改变指定位置的值
	show(listBuffer)
}

输出结果：

str 2.0
str 2.0 num
str 2.0 new

----

集合(Set) >
集合同样允许任意类型的值，但集合中不能包含重复的值。
在使用Set类的apply()方法构建集合时，重复的值会被忽略，如下所示：
scala> var set = Set(1, 1, 's', "str")
set: scala.collection.immutable.Set[Any] = Set(1, s, str)		//重复的值"1"被忽略了

----

映射(Map) >

========


包(Package)与导入(Import) >>
Scala中的包用法基本与Java类似，但在Java的基础上扩充了更多的功能。
与Java不同，Scala中使用"_"符号代替"*"号，表示导入该路径下的所有包和成员。

----

扩展用法 >
Scala中可以在一个语句中导入包内的多个类：
import java.awt.{Color, Font}
在导入一个包的同时可以将包内的类进行重命名：
import java.awt.{Color => JavaColor}
如果不希望某个类被导入，则可以用以下方式隐藏某个类：
import java.awt.{Color => _}
Scala中的import带有类似Java1.6中的static import特性：
import java.lang.Math.abs		//导入Math类中的静态方法abs
在Scala中，包引入了名称相同的类不会发生冲突，而是后引入的类覆盖之前引入的类。
在Scala中，import语句可以出线在任意位置，不必总是放在文件的顶部，import语句的作用域直到该语句块结束。

----

默认包 >
默认情况下，Scala会导入以下几个包路径：
import java.lang._
import scala._
import Predef._
有些Scala包中的类名与Java包中的类名相同，但由于scala包的引入语句在后，因此，例如Scala.StringBuiler类会覆盖Java.lang.StringBuilder。

----

包对象 >
在Scala中，每个包可以带有一个与包名相同的包对象，包内的所有类都可以直接访问该包对象的公有成员。
如下代码所示：

package object Package {
	var num0 = 0
	protected var num1 = 1
	private var num2 = 2
}

package Package {
	object Test extends App {
		println(num0)		//正确，可以直接访问包对象的公有成员，不用使用前缀
		println(num1)		//错误，不能访问包对象的保护成员
		println(num2)		//错误，不能访问包对象的私有成员
	}
}
