Socket通信 >>

使用套接字需要执行4个步骤 >
1.分配套接字接口和初始化
2.连接
3.发送或接收数据
4.关闭套接字

----

涉及的函数 >
包括socket、bind、listen、connect、accpet、recv、send等函数。
相关函数的定义在 "/usr/include/sys/socket.h" 头文件中。

----

socket函数 >
用于初始化一个socket，函数定义为：
int socket(int domain, int type, int protocol);
domain代表使用的域，使用TCP/IP协议应取值 AF_INET。
type代表连接的类型，可取值 SOCK_STREAM 或 SOCK_DGRAM，前者代表TCP可靠连接，后者代表UDP连接
protocol代表使用的协议，一般取0。
成功时函数返回套接字描述符，失败时返回-1，并置errno。

----

bind函数 >
bind()函数将进程与一个套接字接口联系起来，bind通常用于服务器进程为接入客户连接建立一个套接字接口，函数定义为：
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
sockaddr用来表示IP地址，定义为：
struct sockaddr {
	sa_family_t sa_family;		//协议簇
	char sa_data[14];			//地址 + 端口号
}
通常情况下，并不直接创建sockaddr结构体，而是将IP地址的信息写入与sockaddr大小相同的sockaddr_in这个结构体中，sockaddr_in定义在 "/usr/include/netinet/in.h" 文件中，定义如下：
struct sockaddr_in {
    sa_family_t sin_family; 		/* 协议族，address family: AF_INET */
    in_port_t sin_port;   			/* 端口号，port in network byte order */
    struct in_addr sin_addr;   		/* IP地址，internet address */
};
其中，用到的结构体in_addr的定义为：
typedef uint32_t in_addr_t;
struct in_addr {
	in_addr_t s_addr;
};
sockfd参数为socket()函数成功时返回的套接字描述符。
addr为结构体sockaddr的地址，使用时，一般先将IP地址的信息定义在sockaddr_in结构体中，然后在将其强制类型转换为sockaddr类型。
将IP地址赋值给in_addr结构体的s_addr，需要通过inet_addr()函数进行转换，该函数定义在 "/usr/include/arpa/inet.h" 文件中。
addrlen设置了addr结构体中所能容纳的最大字节数。
函数成功返回0，失败时返回-1，并置errno。

----

connect函数 >
connect()函数用于客户端程序，让客户端程序与要与之通信的服务器建立连接，函数定义为：
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
sockfd参数是socket()函数返回的套接字描述符。
addr为需要连接的服务器的地址。

----

listen函数 >
listen()函数用于服务端程序，当创建了套接字接口并使用bind()函数将其与进程关联起来之后，服务器端需要调用listen来监听指定端口的客户端连接，函数定义为：
int listen(int sockfd, int backlog);
sockfd参数是socket()函数返回的套接字描述符。
backlog参数用于设置接入队列的大小(可同时并发接受的连接数)。
成功时返回0，失败时返回-1，并置errno。
listen()函数不是阻塞的。

----

accpet函数 >
当有新客户端连接到服务端时，它们会排入队列，直到服务端准备处理好它们为止，accept会返回一个新的套接字接口，同时原来的套接字接口继续listen指定的端口号，函数定义为：
int accpet(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
sockfd为监听套接字，addr用来接收客户的地址(如果对客户的地址不感兴趣，该参数可填NULL)，addrlen用来接收客户地址的长度(对客户地址不感兴趣则同样可以填NULL)。
返回值为连接套接字，通过该套接字描述符进行通信(连接套接字与socket()函数生成的监听套接字并不相同！服务端使用send()或是recv()等函数发送消息时应该使用连接套接字！)。
accept()函数会阻塞线程。

----

send函数 >
当客户端与服务端成功建立了连接，就可以相互传送数据，发送数据使用send函数，函数定义为：
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
msghdr结构体定义为：
msghdr {
	void *msg_name;				/* optional address */
	socklen_t msg_namelen;		/* size of address */
	struct iovec *msg_iov;		/* scatter/gather array */
	size_t msg_iovlen;			/* # elements in msg_iov */
	void *msg_control;			/* ancillary data, see below */
	size_t msg_controllen;		/* ancillary data buffer len */
	int msg_flags;				/* flags (unused) */
};
其中，用到的结构体iovec的定义为：
struct iovec {					/* Scatter/gather array items */
	void  *iov_base;			/* Starting address */
	size_t iov_len;				/* Number of bytes to transfer */
};
对于UDP协议而言sockfd参数是socket()函数返回的套接字描述符。
对于TCP协议而言sockfd参数是accept()函数返回的连接套接字描述符。
buf参数是接收数据内存buffer地址指针。
参数len指明buffer的大小，单位字节。
参数flag一般为0。
成功发送数据返回发送的字节数，失败时返回-1，并置ernno。

----

recv函数 >
recv()函数用于接收数据，函数定义为：
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
参数的定义类似与send()函数。

----

需要注意的一些问题 >
accept()函数是阻塞的(阻塞当前线程)，但listen、recv、send不会阻塞线程的执行。
UDP协议是无连接的，因此服务端不需要使用listen()和accpet()函数，也不需要使用多线程来接收多个客户请求。
等号赋值 "=" 的优先级比 "==" 符号要低，因此不要直接将socket()/accpet()/send()等socket相关函数的赋值和比较操作同时进行(不要写成 "if (client_fd = accpet(sockfd, NULL, NULL) == -1)" 这样的)，应该注意运算优先级(需要给赋值操作加上小括号)。
服务端使用accept()函数之后会产生新的连接套接字描述符，所有的服务端的send()/recv()应该使用该连接套接字描述符。
需要同时多个用户保持通信连接则需要循环accpet()函数，只运行一次accept()函数则服务端只会与第一个用户通信，后面的用户都会被忽略。
recv()函数的参数中注意正确填写受到字符串的大小(不要写成 "recv(client_fd, str, strlen(str), 0)" 这样的)，不能使用strlen(str)函数计算接收到字符数组大小，因为recv()函数结束后才会改变接收字符数组str中的内容。

========


实例代码(UDP) >>
UDP协议是无连接的，因此服务端不需要使用listen()和accpet()函数，直接使用socket()函数生成套接字描述符，然后使用bind()函数将套接字描述符绑定一个空闲的端口，然后就可以使用recv()函数来接受数据了。由于UDP是无链接的，因此可以不依靠多线程或是select()函数来接收多个用户的数据，也不用针对不同用户生成不同的通信套接字。

----

客户端 >

#include <sys/socket.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char **argv)
{
	char *str = NULL;
	int sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
	
	if (argc != 2)
	{
		printf("指令参数错误！\n");
		_exit(0);
	}
	else
		str = argv[1];
			
	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = 8888;
	addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	
	printf("发送的内容：%s\n", str);
	
	if (connect(sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
		perror("The wrong is: ");
	else
		if (send(sock_fd, str, 50, 0) == -1)
			perror("发送失败：");
	
	close(sock_fd);
	return 0;
}

----

服务端 >

#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>

int main(void)
{
	int sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
	
	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = 8888;
	addr.sin_addr.s_addr = inet_addr("127.0.0.1");
	
	if (bind(sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
		perror("The wrong is: ");
	
	char str[50];
	while (1)
	{
		memset(str, 0, 50);
		if (recv(sock_fd, str, 50, 0) == -1)
			perror("接收失败：");
		else 
			printf("接收到消息：%s\n", str);
	}
	
	close(sock_fd);
	return 0;
}

========


实例代码(TCP) >>
TCP协议要求拥有稳定的连接，因此需要使用listen()函数来监听套接字端口并设置最大并发数，用accept()函数来为每个请求用户的用户生成不同的连接套接字。
同时并行处理多个用户的请求需要使用多线程机制或是select()函数。

----

客户端 >

#include <pthread.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>		//inet_addr()函数

int sock_fd = 0;

void* get_response(void* arg)
{
	char message[10] = {0};
	if (recv(sock_fd, message, 10, 0) == -1)
		perror("获取客户端响应失败：");
	else
		if (!strcmp(message, "close"))
		{
			printf("\n收到来自服务端的关闭指令，关闭客户端！\n");
			close(sock_fd);
			_exit(0);
		}
}

int main(int argc, char **argv)
{
	int user_id = 0;
	pthread_t thread_fd = 0;
	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = 9999;
	addr.sin_addr.s_addr = inet_addr("127.0.0.1");		//向本机发送数据
	
	sock_fd = socket(AF_INET, SOCK_STREAM, 0);
	
	if (sock_fd == -1)
		perror("初始化Socket失败：\n");
		
	if (connect(sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
		perror("连接socket失败：\n");
		
	recv(sock_fd, &user_id, 10, 0);
	printf("登录为用户：[%d]\n", user_id);
	pthread_create(&thread_fd, NULL, get_response, NULL);		//开辟一个线程用于接收服务端的关闭通知
	
	int num = 0;
	char str[50];
	memset(str, 0, 50);			//将字符串置空
	
	while (1)			//使用循环连续发送消息 
	{
		printf("请输入要发送的内容： ");
		scanf("%s", str);
		printf("发送第%d次。\n", ++num);
		if (send(sock_fd, str, 50, 0) == -1)
			perror("发送失败：\n");
		else if (!strcmp(str, "close"))
		{
			printf("关闭socket发送！\n");
			break;
		}
	}
	
	close(sock_fd);
	return 0;
}

----

服务端 >

#include <pthread.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>

#define USER_MAX 10			//定义最大用户数量

pthread_t thread_fd = 0;
int sock_fd = 0;
int num = 0;				//记录接收数据次数	
int user_count = 0;			//用户数量计数
int client_fd[USER_MAX] = {0};		//用一个数组来保存所有用户的连接socket描述符

void* getAccpet(void* arg)
{
	if ((client_fd[user_count] = accept(sock_fd, NULL, NULL)) == -1)
		perror("接受服务失败：\n");
	else 		//每次成功接受新请求就新开启一个线程，让新线程来阻塞继续等待请求
		pthread_create(&thread_fd, NULL, getAccpet, NULL);
	
	int user_id = user_count++;			//定义用户id
	printf("有用户加入socket！当前用户数量为：%d人。\n", user_count);
	send(client_fd[user_id], &user_id, 10, 0);
	
	while (1)
	{
		char message[50];
		memset(message, 0, 50);
		
		if (recv(client_fd[user_id], message, 50, 0) == -1)
			perror("接收消息失败：\n");
		else
		{
			if (!strcmp(message, "close"))
			{
				printf("收到关闭命令！\n关闭socket端口监听！\n");
				for (int i = 0; i < user_count; i++)		//收到关闭信息之后向所有客户端发送关闭消息
					send(client_fd[i], message, 10, 0);
				break;
			}
			else if (!strcmp(message, ""))		//应对用户关闭socket时可能产生的空消息
				break;
			printf("第%d次接收，接收到来自用户[%d]的消息：%s\n", ++num, user_id, message);
		}
	}
	close(client_fd[user_id]);
}

int main(void)
{
	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = 9999;					//当主机端与客户端数据类型兼容时，端口号可以不做转换
	addr.sin_addr.s_addr = INADDR_ANY;		//代表接收任意地址的数据
	sock_fd = socket(AF_INET, SOCK_STREAM, 0);
	
	if (bind(sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
		perror("绑定端口失败！\n");
	
	if (listen(sock_fd, USER_MAX) == -1)
		perror("监听端口失败！\n");
	
	pthread_create(&thread_fd, NULL, getAccpet, &sock_fd);
	pthread_join(thread_fd, NULL);
	
	close(sock_fd);
	return 0;
}

========
