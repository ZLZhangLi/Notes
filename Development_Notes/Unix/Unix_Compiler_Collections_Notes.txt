编译器处理代码简单得来说分为以下几个阶段：
预处理(Preprocessing) -> 编译(Compilation) -> 汇编(Assembly) -> 链接(Linking)

预处理(Preproceessing)
主要处理包括以下过程：
1.将所有的#define删除，并且展开所有的宏定义
2.处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等
3.处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。
4.删除所有注释 "//"和"/* */".
5.添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。
6.保留所有的#pragma编译器指令，因为编译器需要使用它们
预处理之后得到*.i的源码文件。

编译(Compilation)
编译过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。
编译之后得到*.s的汇编源码文件。

汇编(Assembly)
汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程较简单，根据汇编指令和机器指令的对照表一一翻译。
汇编之后得到*.o的目标文件，内容为机器码，不能以普通文本形式的查看(用文本编辑器查看则内容为乱码)。
Unix环境下的汇编器为as。

链接(Linking)
链接程序运行需要的目标文件，以及所依赖的其它库文件，最后生成可执行文件。
Unix环境下的链接器为ld。

在Unix环境下，常用的编译环境为gcc/clang。二者的命令格式类似。

编译源码的基本命令(一次性执行预处理、编译、汇编、链接等所有过程，直接得到可执行文件)：
$ cc [c源码文件] 				//cc为c语言编译器
$ c++ [c++源码文件]			//c++为c++编译器
需要注意的是，不同的开发环境对于cc编译器的定义是不同的，一般情况下，cc指令是一个软链接，指向系统默认的编译器，即使用cc编译器实际调用的是开发环境的默认编译器。
在Linux中，cc的软链接指向gcc编译器。
在FreeBSD中，cc的软链接指向clang编译器。
在Solaris中，cc指令不再是软链接，而是Solaris特有的商业闭源c编译器。
默认情况下，编译器会生成一个名为a.out的二进制可执行文件，运行程序：
$ ./a.out
如果需要指定生成的可执行文件的名称，则需要使用-o参数：
$ cc [源码文件] -o [指定执行文件的名称]
如果仅仅需要编译器进行预处理，则需要使用-E参数：
$ cc -E [源码文件]
默认情况下，编译器会将预处理的结果直接输出到终端上，如果需要将预处理结果输出到文件中，使用(保存预处理后代码的文件一般用*.i做后缀名)：
$ cc -E [源码文件] -o [预处理结果文件名(*.i)]
需要得到编译器生成的汇编代码可以使用-S参数：
$ cc -S [源码文件]
默认情况下生成的是AT&T风格的汇编，如果需要生成intel风格的汇编可以使用参数：
$ cc -S -masm=intel [源码文件]
如果不需要直接生成可执行文件，而是只是生成*.o格式的目标文件的话，则需要使用-c参数：
$ cc -c [源码文件]
默认编译器是不会在生成的执行文件中包含调试标记的，如果需要在生成的二进制文件中保留调试标记，需要使用-g参数：
$ cc -g [源码文件]
这样生成的可执行文件就会包含调试标记，可供gdb之类的调试器进行调试：
$ gdb [生成的可执行文件]

在Unix环境中，系统的库文件一般存放在/lib,/lib64,/usr/lib等目录下，库文件分为以下两种类型：
1.动态链接库 后缀名为*.so 意为share object(共享对象)
2.静态链接库 后缀名为*.a 意为archive(档案文件)
动态链接库可以由编译器生成：
$ cc -shared -fPIC [源码文件] -o [生成动态库的名字]
静态链接库则使用archive实用工具ar来创建，需要先将源码编译成目标文件，再使用ar命令：
$ ar crv [生成静态库的名字] [目标文件]

在Unix环境中，库的命名方式一般为"lib+[库名]"，在编译时如果需要使用链接库，需要-l参数直接加库名而不需要写完整的库文件名字：
$ cc [源码文件] -l[库名]
如果库的位置不在环境变量中，则需要用-L参数手动指定库所在的目录：
$ cc [源码文件] -L[库の目录] -l[库名]
如果源码中引用的头文件位置不在环境变量中，则需要用-I参数手动指定头文件所在的目录：
$ cc [源码文件] -I[头文件の目录]
默认情况下，编译器在链接库时优先使用的是动态链接库，如果在某些特别情况下需要使用静态链接库的话，使用-static参数强制编译器使用静态库：
$ cc -static [源码文件] -l[库名]

需要注意的是，如果一个程序使用了自己编写的动态链接库，需要将自己的动态链接库位置加入环境变量中，否则在运行程序时会提示找不到动态链接库。
静态链接库由于在编译阶段已经将库文件包含在可执行文件中，所以不会出现类似问题。

使用ld命令连接目标文件(*.o)和库：
$ ld [目标文件] -l[库名]
使用ldd命令可以查看一个可执行文件用到了哪些动态链接库：
$ ldd [可执行文件]
使用nm命令可以显示关于对象文件、可执行文件以及对象文件库里的符号信息：
$ nm [可执行文件]

主流的编译器同样支持objective-c(objc)语言，objc语言的源码后缀名为*.m。
要让编译器顺利的编译objc的源码，需要安装objc的对应开发库，在Linux系统中是gnustep库。
使用gcc编译objc源码，需要安装gcc的objc支持包gcc-objc。
编译objc的源码相对编译c/c++源码而言要更复杂，需要使用更多的编译器参数。
使用gnustep-config --objc-flags指令会自动生成编译objc源码需要的编译器参数，并用``符号将指令的结果插入gcc编译指令的参数中。
一般情况下，需要链接libgnustep-base，libobjc这两个库，如果源码使用了GUI库还需要链接libgnustep-gui库。
gcc编译objc源码指令：
$ gcc `gnustep-config --objc-flags` -lobjc -lgnustep-base [源码文件]
由于gnustep-config是与gnu编译器组配套的，故其生成的编译参数并不完全适用于clang编译器，故需要手动指定编译参数以符合clang编译器的要求，根据编译器输出的异常信息将gnustep-config指令生成的参数中不符合要求的参数剔除，并加入其他需要的编译器参数。
clang编译objc源码指令(以 Archlinux + gcc 4.9.2 为例)：
$ clang -fconstant-string-class=NSConstantString -lgnustep-base -lobjc -I/usr/lib/gcc/x86_64-unknown-linux-gnu/[gcc-version]/include [源码文件]

在编译程序时，可以为程序添加代码优化选项来提升程序的运行效率，gcc和clang都有O1，O2，O3三个代码优化级别，O1最低，O3优化最高，使用优化选项能大幅度提升生成二进制文件的执行效率，但会使得生成的程序难以调试。故一般只在程序完成测试之后进入发布阶段才会启用编译优化选项。
