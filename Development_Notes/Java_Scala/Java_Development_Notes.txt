关于Java中的集合类型 >>
与常见的编程语言相同，java中的常见集合类型为List、Set、Map。
List特点：元素有放入顺序，元素可重复。
Map特点：元素按键值对存储，无放入顺序。
Set特点：元素无放入顺序，元素不可重复(注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的)。

在Java中，这三种集合类型都是以接口形式存在的，不能直接使用，要使用这三种类型可以使用其实现类：
List的实现类为LinkedList，ArrayList，Vector；
Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet；
Map接口有三个实现类：HashMap，HashTable，LinkeHashMap；

这些实现类各有优缺点：
ArrayList是非线程安全的，效率高；Vector是基于线程安全的，效率低 。
HashMap非线程安全，高效，支持null；HashTable线程安全，低效，不支持null 。

语法：
List<Type> list = new ArrayList<Type>();
list.add(type);
Map<Key, Type>  map = new HashMap<Key, Type>();
map.put(key, type);

Java支持泛型<>菱形推断，实例化时类型可以省略(Java1.7新特性)，上面的语句实例化可以简写为：
List<Type> list = new ArrayList<>();
Map map = new HashMap<>();
甚至，你还可以直接省略<>符号，完全让编译器推断(Java1.8新特性，一般编译器会隐式推断为Object类型)：
List list = new ArrayList();
Map map = new HashMap();

Set和List都可以得到一个迭代器用于迭代：
Iterator iteratorList = list.iterator();
Iterator iteratorSet = set.iterator();

Map的Key就是一个Set，可以得到Key的集合再迭代：
Set set = map.keySet();
Iterator iteratorSet = set.iterator();

Map使用get(key)可以得到对应的键值，但是这个键值是Object型的，需要通过向下转型来恢复键值类型。
HashMap之类的容器只能一个键对应一个键值，如果需要一个键绑定多个键值可以使用IdentityHashMap。

========


关于泛型方法 >>
Java中的泛型同样支持独立于类的泛型方法，与C++/C#等语言不通，Java在泛型方法中的类型声明放在方法的修饰符(public,static,final,abstract等)之后，返回值声明之前。
Java中的泛型不需要也不支持使用"<>"符号显式指定泛型类型，在泛型方法中输入内容JVM会自动进行类型推倒。

示例代码：

public class Test {
	public static void main(String[] args) {
		Func t = new Func();
		System.out.println(t.getType(123));
		System.out.println(t.getType("Test"));
		System.out.println(t.getType(25.672));
	}
}

class Func {
	public <T> T getType(T t) {
		return t;
	}
}

输出结果：(Windows 10 && JDK 1.8)
123
Test
25.672

========


关于final关键字 >>
Java中有类似C/C++的const关键字的final关键字，final关键字用于定义不可修改的变量，变量加上此关键字之后只能在构造函数或是定义时被初始化。
final还可以用在类之前代表该类不可被继承，也可以用在方法前表示该方法不可被重写。

========


与Access数据库交互 >>
JDK 1.7之前，可以使用JDBC-ODBC桥接Access数据库，但在JAVA8之后，JDBC-ODBC桥被移除，只能使用专有的Access驱动来连接Access数据库(驱动名称：Access_JDBC40.jar)。

----

连接Access数据库的一般步骤 >
String connectUrl = "jdbc:Access:///***.accdb";					//这样写是相对路径
//String connectUrl = "jdbc:Access:///c:/a/b/***.accdb";		//这样写是绝对路径
Class.forName("com.hxtt.sql.access.AccessDriver");
connection = DriverManager.getConnection(connectUrl);
statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);			//后面的两个参数是为了得到resultSet集能够进行last()操作

----

Access数据库的一些小常识 >
1.表单的高级字段设置在"开始 - 视图 - 设计视图"中。
2.配置自增属性需要将字段类型设为"自动编号"。
3.默认情况下，创建的数据类型"数字"的字段大小为"长整型"，这是不支持小数输入的，小数输入会自动被去尾，需要将字段大小设置为"单精度浮点型/双精度浮点型"才能支持小数位。
4.如果需要某个字段的内容唯一不可重复，可以将改字段的索引设置为"有(无重复)"即可。

=======


在Eclipse中查看JDK类源码 >>
与NetBeans不同，在Eclipse中默认是无法直接查看JDK中类库的源码的，需要手动指定源码的位置。
一般情况下，JDK源码位于JDK的安装目录下的"src.zip"文件中。
在Eclipse中按以下步骤添加源码路径：
Window => Preferences => Java => Installed JREs => 选中使用的JRE => Edit => 选中../xxx/rt.jar => Source Attachment Configuration => Exernal location => 选中src.zip => OK => Finish

=======


Swing开发小知识点 >>

设置边框 >
一般的GUI容器类如JFrame、JPanel等都可以通过setBorder()方法来设置边框。
特别的，通过使用透明边框，可以实现控制界面边界空隙的效果(类似于WEB开发中的Margin属性)。
举例：
setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));				//界面上下左右空出10个像素

----

常见的一些控件 >
容器：
JFrame(框架)
JDialog(对话框，比JFrame消耗资源少)
JPanel(面板)
JScrollPane(滚动面板)
文本组件：
JLabel(显示文本)
JTextField(单行编辑框)
JPasswordField(密码编辑框)
JTextArea(多行编辑区域)
表单组件：
JButton
JCheckBox(复选框，方框里打勾)
JRadioButton和ButtonGroup(单选框，圆点)
JComboBox(组合框，俗称下拉列表框)
菜单栏：
JMenubar(菜单栏)
JMenu(菜单栏上的按钮)
JMenuItem(点击菜单按钮弹出的菜单项)
常用的表单组件都有对应的菜单版本，比如JRadioButtonMenuItem、JCheckBoxMenuItem等。
向JMenu中add()菜单项时，虽然可以选择普通组件，但普通组件不能触发菜单效果(点按之后菜单不收回)。

----

利用Map的Key来作为ComoBox的下拉选项 >
先得到map的Key集合：
Set set = map.keySet();
接着将集合转化为对象数组：
Object[] object = set.toArray();
接着构造一个用对象数组初始化的DefaultComboBoxModel对象，并以此构建JComoBox对象：
JComboBox comboBox = new JComboBox(new DefaultComboBoxModel(object));

----

Java事件机制 >
Java的事件机制是通过监听器实现的。
要处理GUI事件，先要根据需求实现事件接口，比如点按事件的ActionListener，处理键盘的KeyListener，处理鼠标的MouseListener等等。
然后在要被监听的的GUI控件上调用对应的addXXXListener()方法将接口实例化的对象作为参数传入即可。

----

在键盘事件中屏蔽指定按键 >
实现KeyListener接口，重写keyTyped(KeyEvent)方法，通过getKeyChar()方法获取输入的字符，然后对其进行判断，如果是想要屏蔽的按键则使用setKeyChar('\0')将其转化为空输入。

举例：(只接受数字输入)
KeyEvent keyEvent = (e) -> {
	if ((e.getKeyChar() < '0' || e.getKeyChar() > '9'))
		e.setKeyChar('\0');
}

----

文本输入监听器DocumentListener >
包含三个方法：
public void changedUpdate(DocumentEvent e)：监听文本属性的变化；
public void insertUpdate(DocumentEvent e)：监听文本内容的插入事件；
public void removeUpdate(DocumentEvent e)：监听文本内容的删除事件。
需要注意的是JTextField控件本身没有addDocumentListener()方法，需要先使用getDocument()方法获取Document对象才能调用addDocumentListener()。
在事件处理方法中，对JTextField对象调用getText()方法即可获得输入文本的内容。

----

显示多行文本 >
JTextField只能用来显示简单的单行文本，涉及到多行文本的复杂情况，需要使用到JTextArea控件：
JTextArea textArea = new JTextArea();
可以设置文本域自动换行：
textArea.setLineWrap(true);
当文本域内容太多无法全部显示时，可以使用JScrollPane控件，将文本域添加到其中：
JScrollPane scrollPane = new JScrollPane(textArea);
这样当文本无法全部显示时会出现滚动条。

----

静态MessageBox方法 >
与Qt一样，Java也提供了弹出MessageBox的静态方法，即JOptionPane.showMessageDialog。
static void showMessageDialog(Component parentComponent, Object message) 									//调出标题为 "Message" 的信息消息对话框。 
static void showMessageDialog(Component parentComponent, Object message, String title, int messageType) 				//调出对话框，它显示使用由 messageType 参数确定的默认图标的 message。 
static void showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon) 						//调出一个显示信息的对话框，为其指定了所有参数。 
其中，messageType可以取DEFAULT_OPTION、YES_NO_OPTION、YES_NO_CANCEL_OPTION 或 OK_CANCEL_OPTION等。
此外，还有showInputDialog、showConfirmDialog等方法可以用于显示其他用途的窗口。

----

使用JTable显示数据库 >
构建一个JTable主要有两种方式：
JTable(Object[][] rowData, Object[] columnNames);
JTable(TableModel dm);
即使用Object数组确定表格模型或是使用TableModel类构建表格模型。
使用对象数组构建表格模型可以先从数组库中读取对应数据，然后将数据存储在对象数组中。
使用TableModel类可以先构建TableMode对象，然后使用TableMode类的成员方法setValueAt(Object aValue, int rowIndex, int columnIndex)设定表格模型每个位置的数据，最后在JTable使用构造函数或在已有的JTable对象调用setModel(TableModel dataModel)成员方法创建表格。