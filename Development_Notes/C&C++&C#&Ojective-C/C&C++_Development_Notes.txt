五大内存区 >>
c/c++中，内存分为5个区，分别是堆区，栈区，静态区，文字常量区，程序代码区。

栈区(stack)：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，地址由高向低减少。 
堆区(heap)：由malloc，new等分配的空间的地址，地址由低向高增长，需要程序员手动释放(free，delete)，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。 
全局/静态变量区(static)：全局变量和静态变量的存储是放在一块的，已初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
文字常量区：常量字符串就是放在这里的，程序结束后由系统释放。
程序代码区：存放函数体的二进制代码。

举例：

int a = 0;		//全局初始化区
char *p1;		//全局未初始化区
int main()
{
	int b; 						//栈区
	char s[] = "abc"; 			//栈区
	char *p2; 					//栈区
	char *p3 = "123456"; 		//"123456"在常量区，p3在栈区
	static int c = 0； 			//全局/静态已初始化区
	p2 = (char*)malloc(10);		//malloc分配得来得10字节的区域就在堆区
	strcpy(p1, "123456"); 		//"123456"放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
	return 0;
}

----


c/c++中函数定义的区别 >>
在c语言中，函数的定义中，参数不能只写参数类型而没有参数名。
在c++中，函数的定义里，参数允许只写参数类型而没有参数名。
在c语言中， "function()" 参数表为空代表这个函数可以接收任意个参数， 而 "function(void)" 才代表函数不接收参数，因此，对于任意参数的函数，都可以用空参数表的形式做函数声明(c语言不支持函数重载，一个函数名对应的函数实现只会有一个)。
但在c++中， "function()" 参数表为空与 "function(void)" 意义相同，都表示该函数不接收任何参数。而且c++支持函数重载，一个函数名根据参数不同可以有多个实现，因此，在c++中函数声明必须与函数定义的原型完全相同。

----


c/c++中static关键字的区别 >>

c语言中的static >
在c语言中，static用在函数/全局变量前表示该函数/全局变量为当前文件的内部函数/全局变量，只能在该文件中被访问，当前文件被include到了其他的文件中是不能被访问的。
static用在局部变量前，则成为静态局部变量，静态局部变量不在栈区分配内存而是在全局变量区中分配内存，因此保存在静态局部变量中的值不会随着函数运行结束而被系统回收，下次执行该函数，该函数内部的静态局部变量不会重新分配内存，而是依然使用上次函数执行结束时的值。

c++中的static >
在c++中，除了上述的用法之外，还可以用在类的成员前，表示"静态成员"，静态成员只能初始化一次，全局仅有一个实体。
静态成员不依赖于类的实例而存在，无需进行类实例化即可直接通过类名进行访问，同时一个类的无论有多少个实例，这些实例的静态成员都指向同一块内存区域(即同一个类的静态成员变量只要有一个变化，其他的也会变化，因为这些类的静态成员变量实际上是同一个)。
静态成员之间能够相互访问，没有this指针，静态成员函数不能访问非静态成员函数和非静态数据成员。
由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长。
静态成员函数在类内声明时使用static关键字，在类外定义时不再使用static关键字。
静态成员变量必须在类外初始化，在类中的静态成员变量定义仅等同于声明，如果静态成员变量没有在类外进行初始化，引用时会出现经典的"未定义引用"错误。
普通静态成员变量不能进行类内初始化，只有常静态成员变量(const static)才能进行类内初始化。

静态成员变量初始化的格式为： 
数据类型 类名::静态成员变量名 = 值;		//静态成员变量的初始化需要在全局区域，不能在函数体内

类的静态成员变量有两种访问形式： 
类实例名.静态成员变量名;
类名::静态成员变量名;

需要注意的是，类的静态成员变量在逻辑上依然受到类的访问权限的制约，private/protected的静态成员变量依然无法在类外访问，但可以在类外赋初值。

----


关于"multiple definition of"(多重定义)错误 >>
在一个头文件中定义一个全局变量，如果这个头文件被多次包含，就会出现多重定义错误，即使你在头文件的定义中正确地使用了"ifndef define endif"宏。正确的定义全局变量的方法是将定义写在代码文件中，然后在头文件里用extern关键字添加声明即可。
"ifndef define endif"宏只能保证编辑阶段代码段不被重复包含，然而变量定义是对每个源文件都有效的，这些源文件编译得到的目标文件里每一个都含有该变量的定义，编译时不会报错，但当这些目标文件连接时，多个目标文件的定义就会产生多重定义冲突。
在c++中，如果全局变量是定义在某个命名空间中的，则在代码文件中的定义和头文件中的带extern关键字的声明都要写在名字相同的命名空间中(命名控件不能加external关键字！)。

举例：

头文件 xxx.h:

namesapce A
{
	extern int a;
}

代码文件 xxx.cc:

namespace A
{
	int a = 0;
}

----


关于"sizeof"运算符 >>
sizeof运算符并不是函数，因此它在编译时起效而不是运行时。
在使用sizeof时需要小心辨别参数是否为指针！
指针与数组的区别之一就是使用sizeof返回的大小不同！
对于数组而言，虽然数组名可以代表数组的首地址，但sizeof对于指针返回的大小总是8(Linux 64bit)或是4(Windows/Linux 32bit)，而将数组名作为参数返回的是"数组类型 * 元素个数"的大小。

举例：

#include <stdio.h>

int main(void)
{
	char *str = "12345";
	char chars[5] = "12345";
	printf("%d %d\n", sizeof(str), sizeof(chars));
	return 0;
}

输出结果：(gcc 4.9.1 & ArchLinux 64bit)
8 5

由结果可知，str的类型为char*，是指针，大小为8，chars类型为char数组，大小为5*1=5。

----


结构体对齐 >>
理论上，结构体的大小等于结构体内的变量大小之和，但实际上由于结构体对齐，结构体的大小与变量大小之和有时并不相等。
在gcc/clang等编译器中，结构体是按照结构体内的最大的成员变量的长度来进行对齐的。即使变量长度没达到最大成员的长度，也会占有该大小的空间。多个小长度的成员能够进行在同一片对齐区域内。但如果出现了最大长度的成员变量，则下一个变量就重新对齐。

举例：

struct
{
	int a;
	char b;
} A;

struct
{
	int a;
	char b;
	char c;
} B;

struct
{
	char b;
	int a;
	char c;
} C;

结构体A的大小是8，按照最大的成员变量的类型int的长度进行对齐，变量b虽然只有1个字节，但结构体的长度为8个字节。
结构体B的大小依旧是8,因为变量b按照int型的4个字节进行对齐，但并未将4个字节的空间完全使用，故变量c继续使用这4个字节的空间。
结构体C的大小是12,因为变量b按照int型的4个字节进行对齐，但下一个变量a也为int型，需要占用4个字节，b的剩余空间不够使用，a变量便会再占用4个字节的空间，而由于a变量是完全使用对齐空间的，下一个变量c则需要重新分配对齐空间，又占用4个字节的空间，故结构体C的大小为4+4+4=12。

----


自增自减运算符的优先级 >>
自增自减运算符根据出现位置的不同，可能在语句之前或语句之后执行，且对整个语句生效(部分编译器约定不同，比如clang)。

举例：

int a = 0;
printf("%d %d\n", a, ++a);

输出结果为：
1 1		(ArchLinux & gcc 4.9.2)
0 1		(ArchLinux & clang 3.5.1) 

在clang中会给出警告，warning: unsequenced modification and access to 'a' ，即无序地修改和存取变量a。

int a[5] = {1, 2, 3, 4, 5};
int b[5] = {0};
int *c = a;
int *d = b;
while (*d++ = *c++);
for (int i = 0; i < 5; i++)
	printf("%d ", b[i]);

输出结果：
1 2 3 4 5

gcc与clang输出相同，但在clang中会给出警告， warning: using the result of an assignment as a condition without parentheses [-Wparentheses]，即仅使用了条件任务而没有使用括号(未使用循环体)。
while (*d++ = *c++);的作用是复制数组内容，先将指针c指向的内容取出即*c，复制到指针d指向的内容即*d，然后执行自增运算符，左右的指针都自增1位，同时指向数组下一个元素，然后while语句判断*d的内容，由于在c/c++中，非0数值都被是为是true，故循环可继续执行，直到数组结束，指针指向空内容为止。
用while (*d++ = *c++);进行复制内容时需要注意，如果复制的内容中含有0，则复制会提前结束。
此类语句还可以用来复制字符串，字符串以\0结尾，复制到字符串结尾自动停止。

----


编译器自动生成类的成员函数 >>
一个没有任何内容的空类实际上并不是空的，编译器会自动为其增加一个空构造函数，复制构造函数，空析构函数，并重载等号为复制对象，还带有一对取址运算符重载，这些函数只有在第一次被调用时，才会别编译器创建。所有这些函数都是inline和public的。
在c++11中，如果类没有定义自己的复制构造函数，则还会生成默认的移动构造函数和并重载等号为移动赋值运算符。如果自行定义了复制构造函数而没有定义移动构造函数，则使用右值对象做参数实例化时，会调用复制构造函数(const左值引用能够绑定在右值对象上，但如果存在移动构造函数则会优先匹配接收右值的移动构造函数)。

举例：

一个空的类class Empty { };
实际上等价于：

class Empty
{
public:
	Empty();					//默认的空构造函数
	Empty(const Empty&);		//复制构造函数
	Empty(Empty&&);				//c++11，移动构造函数
	~Empty();					//默认的析构函数
	Empty* operator&();			//重载取地址运算符
	const Empty* operator&() const;		//带const的取址运算符
	Empty& operator=(const Empty&);		//重载等号为对象内容复制
	Empty& operator=(Empty&&);			//c++11，重载等号为移动对象
}

----


指针加减 >>
在c/c++中，对指针进行加减运算时，并不是直接对地址的大小加上数值得到新的地址，而是原地址加上由 "操作数 * 指针所指向的内容的类型大小" 得到的偏移量计算出的地址。

举例：

#include <stdio.h>

int main(void)
{
	long *a = (long*)0x1;		//内存地址赋值给指针之前需要进行强制类型转换，否则编译器不知道内存的类型
	printf("%p\n", a + 1);		//打印指针使用%p，会以"0x...."的格式输出
	int b[3] = {1, 2, 3};
	printf("%d, %d", *(b + 1), *((int*)(&b + 1) - 1));
	return 0;
}

输出结果：(ArchLinux & gcc 4.9.2)
0x9
2, 3

由例子中不难看出，a + 1代表的地址不是简单地将a的地址(0x1)加上1，而是a的地址加上指针所指向的数据类型(long)的大小(8个字节)乘以操作数1得到的值(0x9)。
对于数组b，单独使用数组名称代表的是数组首元素的地址(&b[0])，b + 1代表的是b[0]的下一个元素(b[1])，而&b代表的是整个数组的首地址，虽然二者(b == &b)的值相同，但是&b + 1代表的是b的整个数组结束后的下一个位置。

----


关于成员函数 >>
在c++中，普通成员函数(包括静态成员函数，但虚函数除外)并不是直接存放在类中的，而是像普通的全局函数一样存放。成员函数在经过编译器处理后，函数名会被改写，而函数名就指明了该函数的类归属以及参数信息。
c++中普通成员函数仅仅是逻辑上存在于类中，成员函数的实际实现并不依赖于类。
c++中空类的大小为1，但向空类中添加任意个普通成员函数类的大小仍然是1。

----


关于虚函数 >>
c++中只有虚函数才能被子类重写(override)，非虚函数会被子类的同名函数隐藏(无论函数原型是否完全相同)。c++中使用virtual关键字定义虚函数，虚函数可以只有函数定义而没有函数实现，没有函数实现的虚函数称为纯虚函数，在c++中使用 "= 0" 来表示一个虚函数为纯虚函数(类似于java和c#中的abstract方法)。拥有一个或以上纯虚函数的类称为抽象类，抽象类是不能被实例化的，也不能在构造函数的内容中使用，但c++11之后可以用在构造函数的初始化序列中。
此外，一个函数不能既是虚函数又是静态函数(static和virtual关键字不能共存)，静态函数是全局的，无需实例化就能被调用，不能够被重写，不能实现向上转型调用子类同名方法实现。

虚函数的实现：
c++中虚函数是通过一张虚函数表来实现的。类实例的最前位置有一个虚表指针(vptr)，指向一张虚函数表，虚函数表中按声明顺序存放了所有该类的虚成员函数的地址，可以通过该表中的地址调用对应的函数实现。虚函数表的最后位置多加了一个节点作为虚函数表的结束标志，在VS中，结束标志是NULL，在gcc中用0表示虚函数表结束，用1表示接下来的位置还有别的虚函数表。
在单继承的情况无override下，子类对象和父类对象的虚函数按照声明顺序出现在虚函数表中，子类的虚函数在表中的位置处于父类虚函数之后。
在单继承且向上转型的情况下，如果父类虚函数被子类override，则父类对象中的虚函数表中存放的虚函数地址会被替换成子类的对应函数地址，以此来实现运行时多态。
在多继承的情况下，子类的对象会按照声明中的顺序生成多个父类虚函数表，子类的成员虚函数被放到了第一个父类虚函数表中。多个虚函数表的之间不是直接相连的，而是按照继承顺序下的该类中的成员内容完全结束之后才会开始下一个类的虚函数表。

举例：

#include <iostream>

using namespace std;

class A				//类A有两个虚函数和一个成员变量，由于内存对齐，类A的大小为16(虚表大小8，变量对齐到8)
{
	virtual int get(int);
	virtual int get();
	char a = 'A';
};

class B : A					//单一继承的情况
{
	virtual int get1();
};

class C
{
	char c = 'C';
	virtual int get();
};

class D : A, C				//多重继承的情况
{
	char d = 'D';
	virtual int get2();
};

class E : public A			//单一继承并发生override的情况
{
	int get();
};

int A::get(int)
{
	cout << "A::get(int)" << endl;
	return 0;
}

int A::get()
{
	cout << "A::get()" << endl;
	return 0;
}

int B::get1()
{
	cout << "B::get1()" << endl;
	return 0;
}

int C::get()
{
	cout << "C::get()" << endl;
	return 0;
}

int D::get2()
{
	cout << "D::get2()" << endl;
	return 0;
}

int E::get()
{
	cout << "E::get()" << endl;
	return 0;
}

int main(void)
{
	A *a = new E;
	B b;
	D d;
	
	//在64bit的Linux中，普通指针的大小为8B，故需要转换为一个占有8个字节的类型来保存内容，否则可能会发生截断
	cout << "调用类A的get(int)函数 ";
	((int (*)())*(long*)*(long*)&d)();
	cout << "调用类A的get()函数 ";
	((int (*)())*((long*)*(long*)&d + 1))();
	cout << "调用类D的get2()函数 ";
	((int (*)())*((long*)*(long*)&d + 2))();
	cout << "类A的变量a的值 " << (char)*((long*)&d + 1) << endl;
	cout << "类C的变量a的值 " << *(char*)((long*)&d + 3) << endl;
	cout << "类D的变量a的值 " << *((char*)((long*)&d + 3) + 1) << endl;		//类D继承于类A和C，D的虚函数添加到了类A虚表的末尾，因而类D中的变量a处于类C中的变量a的下一个位置
	cout << "调用类B的get1()函数 ";
	((int (*)())*((long*)*(long*)&b + 2))();
	cout << "调用类C的get()函数 ";
	((int (*)())*(long*)*((long*)&d + 2))();
	cout << "调用类A的get(int)函数 ";
	((int (*)())*((long*)*(long*)&*a))();
	cout << "向上转型使用A类指针调用类E的get()函数 ";
	((int (*)())*((long*)*(long*)&*a + 1))();
	return 0;
}

输出结果：(ArchLinux & gcc 4.9.2)
调用类A的get(int)函数 A::get(int)
调用类A的get()函数 A::get()
调用类D的get2()函数 D::get2()
类A的变量a的值 A
类C的变量a的值 C
类D的变量a的值 D
调用类B的get1()函数 B::get1()
调用类C的get()函数 C::get()
调用类A的get(int)函数 A::get(int)
向上转型使用A类指针调用类E的get()函数 E::get()

由结果可知，D类继承于A，C两个类，生成类两张虚表，D的虚函数get2的地址保存在A的虚函数表中，位于虚函数表的最后一个位置。A类的大小为16，A类的内容结束后就是C的内容，因此C的虚表指针地址为 "类实例起始地址 + 16"即 &d + 16，用8个字节的long型做转换可以写成 "(long*)&d + 2"，而D类自己的变量a地址位于类C结束位置的下一个位置(类D的虚函数在A末尾，故没有单独虚表)，同时又因为类D没有单独的虚表，则根据结构体长度对齐的原则，类D的变量a会紧接着类C的变量a，即 "(char*)((long*)&d + 3) + 1"。
E类继承与A，只有一张虚表，通过向上转型得到的实例*a中，E的get()重写了父类A的虚函数get()，"(long*)*(long*)&*a"是虚函数表的首地址，存放是A类的第一个成员虚函数get(int)，"(long*)*(long*)&*a + 1"是虚函数表中的第二个内容的地址，地址中存放的原本是类A的第二个虚函数get()，但在向上转型的实例中，被替换成了子类E的get()函数的地址。
在VS中运行此段代码，只会输出前两个结果，因为在VS中，多个虚表之间不是直接相连的，在类成员结束之后并未直接开始下一个虚表，而是隔着一些特殊的字段并用0进行填充，不能通过直接加减类实例地址来得到下一个虚表地址。

c++的对象模型：
在有虚函数且多重继承的情况下，多个父类按照其声明顺序依次排列，而每个类的区域内部先是一个虚表指针(vptr)，然后是普通成员变量，子类与第一个继承的父类共用一个虚表，子类的普通成员紧跟在最后一个父类的普通成员之后。
类的成员函数和静态成员变量实际是全局的，因此类的实例中并不包含这些内容，使用sizeof()计算类的大小时也不会把这些内容计算进去，通过地址访问类的成员进行地址计算时需要忽略这些成员的大小。

----


默认参数 >>
c++允许在定义函数是给函数的参数设定一个默认值，在调用这个函数时，如果没有给出对应参数的值，就会使用默认的参数值。
在调用具有默认参数的函数时，如果使用参数了一个参数的默认值，则其它带有默认值的参数也应该使用默认值，如果不准备使用参数的默认值，则所有带默认值的参数的默认值都不应该被使用。
带有默认值的函数参数需要连续出现，即一旦有一个参数开始有默认值，后面的参数都需要有默认值(也就是说带有默认值的参数与无默认值的参数不能够交错出现)。
参数的默认值只能在函数的声明或定义的其中一处指定，不能两处都指定。
带有默认参数的函数在定义时需要注意不能与重载函数相冲突。

举例：

int got(int a = 3);
int got(int a = 3)		//编译报错，默认参数只能出现在定义或是声明中的其中一处
{
	return a;
}
int get(int b = 3, int a)		//编译报错，一旦有一个参数带有默认值，后面的参数都应拥有默认值
{
	return b;
}
int get(int b = 3)
{
	return b;
}
int get()
{
	return a;
}
int main(void)
{
	get();		//编译报错，有两个函数都符合要求。
	return 0;
}

----


函数定义嵌套 >>
在c/c++标准中，函数定义必须是完全平行、相互独立的，也就是说函数定义的内部不能嵌套另一个函数的定义。
但是gcc扩充了c的语法，在gcc中嵌套函数定义是允许的行为(只有gcc！clang/clang++/g++并不允许嵌套函数定义！)
以下的代码在gcc中可以顺利编译并得到执行结果：(测试平台 ArchLinux & gcc 4.9.2)

#include <stdio.h>

int got(int num)
{
	int got(int num)
	{
		return num;
	}
	return got(num);
}

int main(void)
{
	printf("%d\n", got(100));
	return 0;
}

输出结果：
100

给神一样的gcc给跪了。。。。

----


关于explicit关键字 >>
c++中的关键字explicit作用是防止构造函数隐式转换的发生。
默认情况下，在c++中，使用 "类名 实例名 = 参数" 的形式创建一个类的实例，当 "参数" 刚好符合类的构造函数参数要求，此时编译器会隐式的调用这个类的构造函数来创建类的实例。但有些情况下，我们需要避免这种隐式转换的发生，这时，在类的构造函数声明时，在在构造函数名之前加上explicit关键字即可避免隐式转换发生。
采用explicit关键字声明的构造函数只能够被显式地调用。

----


关于restrict关键字 >>
c99中新引入了关键字restrict，restrict关键字用在指针的定义中，格式为"变量类型* restrict 指针名"，作用是是告知编译器该指针始终指向首次初始化时的内容，不会发生改变。
restrict关键字不会改变指针的用法，但会让编译器更加安全高效准确地优化代码，使用restrict关键字定义的指针的指向不应进行改动。
restrict关键字只在支持c99以上的c编译器中使用，c++没有引入这个关键字。

----


关于左值引用(lvalue reference)和右值引用(rvalue reference) >>
在c++中，左值(lvalue)代表持久性的对象，右值(rvalue)代表短暂的对象，左值可以被取地址，右值不能被取地址。

引用绑定遵循以下规则：
非const左值引用可以绑定到非const左值。
const左值引用可以绑定到任意左值和任意右值(无论是否const)。
非const右值引用可以绑定到非const右值。
const右值引用可以绑定到任意右值(无论是否const)。

需要注意的是，无论左值引用或是右值引用本身都是左值，因此虽然不能直接对右值取地址，但是可以对右值引用取地址。
引用一但绑定就不可更改，因此引用与指针不同，指针分为指向const内容的指针(const 类型名 *指针名)和自身保存地址不可变的const指针(类型名* const 指针名)，而引用本身一定是不可变的，因此只有绑定const值的引用(const 类型名 &引用名)，而没有真正的const引用，"类型名& const 引用名"这样的定义是不被编译器允许的。

举例：

const int &a = 1;				//正确，const左值引用可以绑定到右值
int &&b = 1;					//正确，非const右值引用可以绑定到右值

int &x = 1;						//错误，非const左值引用不能绑定到右值
int &x = a;						//错误，非const左值引用不能绑定到const左值
int &x = b;						//正确，非const左值引用可以绑定到非const左值
const int &x = std::move(a);	//正确，const左值引用可以绑定到const右值
const int &x = std::move(b);	//正确，const左值引用可以绑定到非const右值
int &&x = std::move(a);			//错误，非const右值引用不能绑定到const右值
int &&x = std::move(b);			//正确，非const右值引用可以绑定到非const右值
const int &&x = std::move(a);	//正确，const右值引用可以绑定到非const右值
const int &&x = std::move(b);	//正确，const右值引用可以绑定到非const右值

----


关于绑定指针的引用 >>
c++中，引用同样可以绑定在指针类型上，具体格式为：

左值引用绑定指针 > 
类型名 *&引用名 = 变量名;
类型名* const &引用名 = const右值/非const右值/变量名;

右值引用绑定指针 >
类型名 *&&引用名 = 非const右值;
类型名* const &&引用名 = const右值/非const右值;

举例：

//一般来说，带const限定的变量可以接收非const变量的值，反之则不可。

int a = 0;
const int b = 0;
int *c = &a;
//int *d = &b;				//错误，const变量的地址应该有指向const变量的指针保存
const int *d = &b;
const int *e = &a;			//正确，非const变量的地址也可以由指向const变量的指针保存
int* const f = &a;			//正确，const指针
//int *g = f;				//错误，const指针不能传递给非const指针
const int* const g = f;		//正确，const指针可以传递给指向const变量的const指针

int *&x = c;							//非const左值引用绑定非const指针变量(非const左值)
int *&&x = &a;							//右值引用直接绑定到非const地址(非const右值)
int* const &x = &a;						//const左值引用绑定到非const地址(非const右值)
const int* const &x = std::move(d);		//const左值引用绑定到指向const值的指针的右值，第一个const代表引用绑定的指针所指向的值是带有const的
const int* const &&x = std::move(e);	//const右值引用绑定到指向const值的指针的右值
int* const &&x = std::move(f);			//const右值引用绑定到const指针的右值
const int *&&x = std::move(d);			//非const右值引用绑定到指向const值的指针的右值
const int* const &x = std::move(g);
const int* const &&x = std::move(g);	//对于指向const变量的const指针的右值可以使用const左值引用或const右值引用来绑定，第一个const不能省略！

----


关于泛型(模版)>>
泛型在c++中的实现叫做模版(template)。
c++的模版可以用在类和函数中。当模版用在函数中时，调用模版函数时可以不显式指定模版类型，编译器会根据调用函数的参数类型进行自动推导。此外，不能给一个模版类型指定两种不同的类型。
当模板函数在接收特定参数时如果与已有的普通函数的原型相同，则会优先调用普通函数的实现。

举例：

template <class T>
T get(T t, T c)
{
	return t;
}

int main(void)
{
	cout << get<int>(123, 123) << endl;		//正确，显式指定模版函数的模版类型为int
	cout << get(123, 123) << endl;			//正确，根据调用函数时传入的参数推导出模版类型为int
	//cout << get(123, 12.3) << endl;		//错误，没有显式指定模版类型时，对于同一个类型传入模版的参数必须类型完全相同，而get(123, 12.3)会让编译器推导为get(int, double)
	cout << get<int>(123, 12.3) << endl;	//正确，如果在调用模版函数时显式指定了模版类型，则对于同一个模版类型可以使用兼容的参数类型(不一定要完全相同)，编译器会自动进行隐式的强制类型转换
	return 0;
}

模版还可以用在类或者类的内部的某个函数中。
当模版用在类中时，则该类在实例化时必须显式指定模版的类型。
当模版用在类内部的某个成员函数中时，带有模版函数的类实例化方式与普通类无异，而该类的成员模版函数使用方式类似于普通模版函数，可以不显式地指定模版类型而让编译器来推导。

c++的模版能够接收类型形参和部分非类型形参，模版的非类型形参只能是整形、指针和引用，比如int a可以作为模版的形参，但double a、string a则不可以，而double *a、string *a则可以，对象的引用和指针是符合要求的。
调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。需要注意的是，任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。
全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。
全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。
sizeof表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。
模版函数如果使用了非类型形参，则在调用该模版函数时必须显式指定模版实参，因为编译器只能推导模版类型，非类型的模版参数需要显式地指定。

c++11之前可以为模版类的类型形参提供默认值，但不能为模板函数的类型形参提供默认值。模板函数和模板类都可以为模板的非类型形参提供默认值。
在c++11之后，无论模版函数或是模版类的类型形参和非类型形参都可以拥有默认值(g++ 4.9.2 & vs 2013测试通过)。
另外，模版形参默认值的用法类似于函数参数形参默认值，即从第一个有默认值的形参开始，之后的形参都应拥有默认值，并且形参默认值在声明或定义只需要出现一处即可。
即使一个模版类的所有模版形参都拥有默认值，全部采用默认参数来实例化这个模版类时类名之后依然需要有一对空的尖括号"<>"来表示实例化的是一个模版类。

----


模板与重载 >>
c++中模板是在编译时根据实例化时使用的类型编译成对应的函数，因此，如果一个模板类成员函数(无论是否静态)在确定了类型之后与原有的成员函数原型发生冲突则在编译时就会报错。同样的，即使模板函数在使用某种类型时可能与已有的函数原型发生冲突，但只要没使用该类型，就能通过编译(全局函数不受此限制，即使模板函数原型与某个普通函数完全相同时，依然可以通过编译)。

举例：(需要c++1y支持)

template <typename T>
class A
{
public:
	auto get(T, T);
	int get(int, int);
};

template <class T>
auto A<T>::get(T, T)
{
	/*函数体*/
}

当A类使用int型作为模板实例化类型时，就会与原有函数原型发生冲突。
c++作为编译性语言，模板是在编译期实现的，属于编译时多态的一种。

----


常用的c语言标准库函数 >>
初始化内存块常使用memset()函数，函数定义为：

#include <string.h>
void* memset(void *s, int c, size_t n);

作用是将指针s所指向的区域的前n位用ASC码值c填充。
注意c的取值为ASC码值，即如果c取0，则指针s所指向的区域的前n为全部用空白填充(相当于全是'\0')，如果c取49,则相当于用数字"1"来填充，依此类推。

----


关于在switch的case语句中定义局部变量 >>
在c语言中，不允许在switch的case语句内定义局部变量，以下语句是错误的：

int a = 0;
switch (a)
{
case 0:
	int b = 0;
	break;
}

无法通过编译，c语言编译器会提示"crosses initialization of 'int b'"。
以上语句在c++编译器中也会给出同样的错误。
但是c++中允许另一种写法：

int a = 0;
switch (a)
{
case 0:
	int b;
	b = 0;
	break;
}

将定义与赋值拆开可以通过c++编译器，但依旧会在c编译器中报错。

----