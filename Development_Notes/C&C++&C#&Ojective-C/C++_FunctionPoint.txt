c/c++中常见的数据类型大小 >>
Linux (64bit) gcc
short: 2
int: 4
unsigned int: 4
long int(long): 8
long long: 8
char: 1
float: 4
double: 8
long double: 16
普通指针&静态成员指针 8
普通成员指针 16 (&类名::函数名)

Windows (64bit) VirtualStudio 2013 (32bit)
short: 2
int: 4
unsigned int: 4
long int(long): 4
long long: 8
char: 1
float: 4
double: 8
long double: 8
普通指针&静态成员指针 4
普通成员指针根据继承方式的不同可能出现 单背指针，双倍大小，三倍大小甚至四倍大小指针。



定义函数指针 >>
可以使用typedef关键字来定义函数指针。定义完成后，指针名就是一个类型，定义返回函数指针的函数时可以直接将该类型名做返回类型。
也可以用#define来定义，define只是做简单的内容替换(需要注意运算符优先级)。
使用typedef或#define时，typedef句末有分号，#define没有。使用二者进行定义时不要加多余的括号(比如将整个表达式扩起来)

举例：

现在有一个函数getNum，定义如下：

int getNum(int a)
{
	reuturn a;
}

使用typedef关键字定义类型：

typedef int (*P)(int);
P p = getNum;

此时，p就是一个指向函数getNum的函数指针。
使用#define进行宏定义：

#define T(s) int (*s)(int)
T(s) = getNum;

此时，s也是一个指向函数getNum的函数指针。



一般函数指针 >>
定义： 返回类型 (*指针名)(参数表) = 函数名
使用： 指针名(实参)

返回函数指针的函数 >>
定义： 所指向函数的返回类型 (*函数名(函数参数表))(所指向函数的参数表)
使用： 符合所指向函数的函数原型的函数指针 = 函数名(实参)

c++普通成员函数指针 >>
定义： 返回类型 (类名::*指针名)(参数表) = &类名::函数名
使用： (类实例名.*指针名)(实参)

c++静态成员函数指针(类似于普通函数指针) >>
定义： 返回类型 (*指针名)(参数表) = &类名::函数名
or：  返回类型 (*指针名)(参数表) = &(类名::函数名)
使用： 指针名(实参)
or：  (*指针名)(实参)

举例：

#define T(s) int (*s)(int)
using P = int (*)(int);		//等价与typedef int (*P)(int);

#include <iostream>

using namespace std;

class A
{
public:
	int m = 100;
	int getNum(int);
	static int getZero(int);
};

int A::getNum(int num)
{
	return num;
}

int A::getZero(int)
{
	return 0;
}

int getOne(int)
{
	return 1;
}

int main()
{
	A a;
	P p = getOne;
	T(s) = A::getZero;
	int (A::*x)(int) = &A::getNum;
	cout << p(0) << " " << s(0) << " " << (a.*x)(123) << endl;
	cout << sizeof(p) << " " << sizeof(s) << " " << sizeof(x) << endl;
	return 0;
}

输出结果：(gcc 4.9.1 & ArchLinux 64bit)
1 0 123
8 8 16

输出结果：(VS 2013 & Windows 8.1 64bit)
1 0 123
4 4 4

由例子可知：
函数的函数名代表该函数的地址，可以直接传递给符合要求(函数签名对应)的函数指针变量，可以像使用原函数一样使用函数指针(c++类非静态成员函数指针不行！)。
c++标准规定，非静态成员函数不是左值，因此非静态成员函数不存在表达式中从函数左值到指针右值的隐式转换，非静态成员函数指针必须通过&运算符显式获得。故c++中的成员指针 "&类名::成员名" 格式是固定的，不能有任何改动，在gcc/clang中，普通成员指针是普通指针变量大小的一倍。
需要注意的是，类的成员中如果加了static关键字，则类似与全局成员，类的静态成员指针为正常的8字节(64bit OS)，定义与使用指针时也类似与普通函数指针，赋值可以有多种方式。
此外，微软的VS允许以 "&(类名::普通成员名)" 的形式来赋值普通成员函数指针，但这样的方式在更为规范的编译器(例如gcc/clang)中会报错(相比标准多了一个括号，gcc/clang将 "类名::普通成员名" 视为直接访问非静态变量，因此报错)。微软的VS中，成员指针的大小会随着虚继承和多重继承等情况而出现不同的大小。
gcc/clang等编译环境不支持虚继承的情况下，从子类创建虚基类的成员函数指针，但VS支持这个特性。



WIKI 中关于函数指针的介绍 >>
不同于普通函数，类成员函数的调用有一个特殊的不写在形参表里的隐式参数：类实例的地址。因此，C++的类成员函数调用使用thiscall调用协议。类成员函数是限定(qualification)于所属类之中的。
同样，类成员函数指针与普通函数指针不是一码事。前者要用.*与->*运算符来使用，而后者可以用*运算符（称为“解引用”dereference，或称“间址”indirection）。普通函数指针实际上保存的是函数体的开始地址，因此也称“代码指针”，以区别于c/c++最常用的数据指针。而类成员函数指针就不仅仅是类成员函数的内存起始地址，还需要能解决因为c++的多重继承、虚继承而带来的类实例地址的调整问题。因此，普通函数指针的尺寸就是普通指针的尺寸，例如32位程序是4字节，64位程序是8字节。而类成员函数指针的尺寸最多有4种可能：

单倍指针尺寸 >
对于非派生类、单继承类，类成员函数指针保存的就是成员函数的内存起始地址。
双倍指针尺寸 >
对于多重继承类，类成员函数指针保存的是成员函数的内存起始地址与this指针调整值。因为对于多继承类的类成员函数指针，可能对应于该类自身的成员函数，或者最左基类的成员函数，这两种情形都不需要调整this指针。如果类成员函数指针保存的其他的非最左基类的成员函数的地址，根据c++标准，非最左基类实例的开始地址与派生类实例的开始地址肯定不同，所以需要调整this指针，使其指向非最左基类实例。
三倍指针尺寸 >
对于多重继承且虚继承的类。类成员函数指针保存的就是成员函数的内存起始地址、this指针调整值、虚基类调整值在虚基表（vbtable）中的位置共计3项。以常见的“菱形虚继承”为例。最派生类多重继承了两个类，称为左父类、右父类；两个父类共享继承了一个虚基类。最派生类的成员函数指针可能保存了这四个类的成员函数的内存地址。如果成员函数指针保存了最派生类或左父类的成员函数地址，则最为简单，不需要调整this指针值。如果如果成员函数指针保存了右父类的成员函数地址，则this指针值要加上一个偏移值，指向右父类实例的地址。如果成员函数指针保存了虚基类的成员函数地址，由于C++类继承的复杂多态性质，必须到最派生类虚基表的相应条目查出虚基类地址的偏移值，依此来调整this指针指向虚基类。
四倍指针尺寸 >
c++标准允许一个仅仅是声明但没有定义的类（forward declaration）的成员函数指针，可以被定义、被调用。这种情况下，实际上对该类一无所知。这称作未知类型（unknown）的成员函数指针。该类的成员函数指针需要留出4项数据位置，分别用于保存成员函数的内存起始地址、this指针调整值、虚基表到类的开始地址的偏移值（vtordisp）、虚基类调整值在虚基表（vbtable）中的位置，共计4项。

c++标准并没有明确规定类成员指针在派生类与基类之间的类型转换。但不允许类成员函数指针与其它无继承关系的类的成员函数指针互相转换。不允许与普通函数指针互相转换。
如果把基类的虚函数赋给派生类的成员函数指针，例如：

DerivedClass_Func_to_Mem = &BaseClass::virtualFunc;

实际上是把基类虚表中该虚函数条目对应到了派生类成员函数指针。调用该成员函数指针会执行到哪个函数，需要动态决定。
类成员函数指针可以用0赋值；可以用==运算符、!=运算符。但不允许使用其他的指针算术与比较运算符，如>、<等等。
不能把类的静态成员函数赋值给类成员函数指针。类的静态函数只能赋值给普通函数指针。因为类的静态成员函数不具有this指针，不采用thiscall调用协议，实际上是限定于类作用域的普通函数。 所以，确切地说，应该称“类非静态成员函数指针”。
对于g++编译器，不支持把虚基类的成员函数指针赋给派生类的成员函数指针。也即，g++不支持在虚继承关系下的成员函数指针的upcast。这大大简化了g++成员函数指针的实现难度。g++编译出来的成员函数指针长度都是两倍普通指针的大小，其中的高位是用于多重继承时调整this指针的偏移值，单继承时该值为0；低位是个union结构，对于非虚成员函数就是函数体的内存起始地址，对于虚函数是该函数在虚表（vtable）中的地址字节偏移量再加上1。这是因为，函数体的内存起始地址起码是4字节边界对齐，所以该值是4的的倍数；而虚表中每个条目是4字节长度（对于32位程序），虚函数所对应的虚表条目在虚表中的按字节计算的偏移量也是4的倍数，加上1后就是个奇数。从而可以区分非虚函数与虚函数两种情形。
Microsoft Visual C++编译器支持在虚继承关系下的成员函数指针的upcast。这大大复杂化了该编译器的成员函数指针的实现。Visual C++定义了三个关键字：__single、__multi、__virtual_inheritance分别对应于类是单继承、多重继承、虚继承关系；此外还有第四种情况：类在提前声明（forward declaration）时的未知类型（unknown）成员函数指针。上述四种情况，Visual C++编译出的32位程序的成员函数指针长度分别是4字节、8字节、12字节、16字节。上述3个继承关系关键字用于在类定义时，显式规定该类的成员函数指针的长度及保存在其中的信息类别。[1]如果在一个源文件（编译单元）中在没有一个类的定义的情况下调用了该类的未知类型（unknown）成员函数指针，显然必须在其他源文件中对该未知类型（unknown）成员函数指针给出类型定义并赋值，这就必须使用编译选项/vmg来编译此源文件。/vmg编译选项使得编译单元中所有的类成员函数指针均为四倍尺寸。可以用上述3个Microsoft定义的继承关系关键字把那些不是未知类型的成员函数指针显式地给出其类继承关系是单继承、多继承、虚继承，从而使该类的成员函数指针分别是单倍、二倍、三倍的尺寸。
