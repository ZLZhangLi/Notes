C#的入口函数 >>
C#的入口函数允许以下4种形式的入口函数：
static void Main();
static void Main(string[] args);
static int Main();
static int Main(string[] args);
C#允许多种入口函数形式，一般采用第二种(默认)。
与Java不同，C#并不强制要求主类的类名与主类所在文件的文件名相同。

========


C#的数据类型 >>
C#的数据类型分为两类：值类型和引用类型。
值类型用于存储数据，引用类型用于定义行为。

----

值类型(Value Type) >
值类型具体包括预定义的值类型，自定义值类型和枚举类型。

所有值类型隐式派生于System.ValueType类。
系统预定义的值类型int是System命名空间中Sytem.Int32结构体的别名。
System.Int32结构的定义为：public struct Int32 : IComparable, IFormattable, IConvertible, IComparable<int>, IEquatable<int>;

其它的预定义值类型也是类似的结构类型(Struct)的别名：
sbyte => System.SByte
short => System.Int16
int => System.Int32
long => System.Int64
byte => System.Byte
ushort => System.UInt16
uint => System.UInt32
ulong => System.UInt64
char => System.Char
float => System.Single
double => System.Double
decimal => System.Decimal			//用于财务计算
bool => System.Boolean
enum => System.Enum

用户定义的结构体，从System.ValueType类中继承。(public abstract class ValueType)
可空类型对应System.Nullable<T>结构体。(public struct Nullable<T> where T : struct)

值类型实例通常分配在线程的栈(Stack)上，并且不包含任何指向实例数据的指针，因为变量本身就包含了其实例数据。
值类型在复制时是值传递，会复制当前值类型变量包含的内容。

----

引用类型(Reference Type) >
引用类型包括数组(派生于System.Array)，字符串string(System.String类的别名)，自定义类(派生于System.Object)，委托类型(派生于System.Delegate)，object类型(System.Object)的别名。

相比之下，值类型和引用类型都可以实现接口，但值类型不能再派生出新的子类型。
引用类型可以为null，但值类型不行(除了可空类型)。
引用类型复制是传递引用，值类型复制是拷贝整个对象。
值类型分配内存在线程栈上，出栈自动释放；引用类型分配内存在托管堆上，由GC负责内存回收。

========


成员属性 >>
C#类中成员有一种被称为[属性]。
属性的访问方式与成员变量类似，属性的作用类似一个简化版的函数，通过定义set和get块的内容(set和get可以分别设置访问权限，不加关键字时访问权限与所在的属性相同)，能够通过属性给成员变量赋值或是获取成员变量的值。
set块中使用关键字value来代表给属性的赋值。get块必须返回一个与属性类型相符的值。
set块和get块不是必须同时存在的，只有set/get块的属性被称为只读/只写属性。

举例：

using System;

class A
{
	int num = 0;
	
	public int a
	{
		set
		{
			num = value;
		}
		get
		{
			return num;
		}
	}
}

class Program
{
	static void Main(string[] args)
	{
		A a = new A();
		Console.WriteLine(a.a);
		a.a = 100;
		Console.WriteLine(a.a);
	}
}

输出结果：
0
100

可知，对类A中属性a的赋值通过a的set块中的value传给了A类私有成员num，通过a的get块获取了私有成员num的值。

----

自动成员属性 >
在C#3.0之后，可以使用更为简便的自动属性，只需使用set、get关键字，而不必定义一个与属性相关的变量并编写set、get块代码，编译器会自动生成一个私有变量保存属性的内容。
如上个例子中的成员属性a可以简写成：
public int a { get; set; }
同时，不用定义私有变量num来存储属性的内容。

========


关于委托(delegate)和事件(event) >>

关于委托(delegate) >
委托是C#特有的概念，委托的作用类似于C/C++中的函数指针，但委托是类型安全的，在C#中，委托被当作一个类看待，因而使用方式与class类似。委托支持加减运算符操作，一个委托实例能够绑定多个签名相同的函数。

定义委托：
delegate 返回值类型 委托名(参数表);

需要注意的是，委托与类以及函数类似，委托的定义是不能嵌套在函数中的。委托的定义可以在全局、命名空间或是作为某个类的成员，但委托的定义不能放在函数的函数体内。
委托前可以使用访问权限关键字(public, private, protected等)进行限制，但委托不能使用static关键字(委托实例作为一个类的成员存在时可以使用static关键字)。
委托可以绑定static或是非static成员函数，委托同样可以绑定当前类之外的符合签名要求的其它类的可见成员函数(public、internal成员)。
delegate关键字还可以用来定义匿名函数，实例化委托或是增加委托实例绑定时都可以使用委托匿名函数。

委托实例化：
委托名 委托实例名;									//与事件相同，委托也可以只定义不初始化
委托名 委托实例名 = new 委托名(符合委托签名的函数名);
委托名 委托实例名 = 符合委托签名的当前类成员函数名;			//可以省略使用构造函数
委托名 委托实例名 = 类实例/类名.符合委托签名的公有非static/static成员函数名;	//委托同样可以绑定到其他类的可见成员函数
委托名 委托实例名 = delegate(符合委托签名的参数表)			//匿名委托
{
	函数内容;
};

增加/删除委托绑定函数：
委托实例名 += 符合委托签名的函数名;
委托实例名 -= 已绑定到委托的函数名;
委托实例名 += delegate(符合委托签名的参数表)
{
	函数内容;
};

一个委托可以同加减运算符动态地更改绑定的函数个数。

调用委托：
委托实例名(符合委托签名的参数表);

调用委托会把委托绑定的所有函数按照绑定的先后次序依次执行，如果绑定的函数拥有返回值，则将最后一个绑定函数的返回值作为整个委托实例的返回值。
委托类型作为函数的形参时，传入实参时可以直接使用符合委托签名的函数名，无需手动使用new操作符构建委托对象。

----

关于事件(event) >
事件是委托的扩展概念，事件本质上是一类特殊的委托实例(不是委托类型)，创建事件前需要先定义一个委托，然后才能将事件与委托绑定。

定义事件：
event 委托名 事件名;
event 委托名 事件名 = new 委托名(符合委托签名的函数名);		//事件也可以在定义时就初始化
event 委托名 事件名 = 符合委托函数签名的函数名;				//可以省略使用构造函数
event 委托名 事件名 = delegate(符合委托签名的参数表)		//匿名委托
{
	函数内容;
};

给事件添加/删除处理函数：
事件名 += 符合委托签名的函数名;
事件名 -= 已绑定到事件的函数名;
事件名 += delegate(符合委托签名的参数表)
{
	函数内容;
};

触发事件：
事件名(符合委托签名的参数表);

由于事件是一种特殊的委托实例，因此与委托不同，不能在全局区域和命名空间中定义事件，只能将事件作为某个类的成员来进行定义，事件与普通的成员类似，受到类的访问权限控制。
调用事件与调用委托实例方法是完全相同的。
事件机制是其他C#高级技术的基础。

举例：
 
using System;

namespace ConsoleApplication1
{
	delegate void getMessage(string mes);					//委托可以定义在全局区域或是命名空间

	class Program
	{
		static void Main(string[] args)
		{
			Event events = new Event();
			events.myEvent += Program.eventHandler;
			events.myEvent += delegate(string str)			//事件绑定到委托匿名方法
			{
				Console.WriteLine("This is the {0}!", str);
			};
			events.showEvent("Test Text");					//触发事件
		}

		static void eventHandler(string str)
		{
			Console.WriteLine("This is the eventHandler!");
		}
	}

	class Event
	{
		public event getMessage myEvent;		//定义事件
		public void showEvent(string str)		//触发事件的函数
		{
			myEvent(str);		//调用事件实例，触发事件
		}
	}
}

输出结果：
This is the eventHandler!
This is the Test Text!

========


Lambda表达式 >>
在C#3.0之后，引入了Lambda表达式的概念，用于实现函数式编程。基本语法为：
(参数表) => 单一表达式;
(参数表) => { 多行表达式; };
参数表中可以不显式指定参数类型，在表达式只有一条语句时，该语句如有返回值，则被作为整个Lambda表达式的返回值，如果表达式有多条语句(使用花括号)时，需要显式使用return关键字指定返回值。
参数表可以不指定参数类型交由编译器隐式推导，也可以显式指定参数类型，显式指定与隐式指定不可混用，一旦有参数使用了显式指定或隐式指定，其余的参数必须使用相同的指定方式。

----

Lambda表达式实现委托(delegate) >
在C#中，Lambda表达式概念与委托相通，可以使用Lambda表达式以更简洁的方式代替匿名委托实现委托实例。

举例：

delegate int GetDouble(double num1, double num2);
GetDouble getDouble1 = delegate(double num1, double num2) { return (int)(num1 + num2); };
GetDouble getDouble2 = (num1, num2) => (int)(num1 + num2);
GetDouble getDouble3 = (double num1, double num2) => { return (int)(num1 + num2); };		//三种形式效果完全相同

----

使用类型表示Lambda表达式 >
使用Action表示不带参数和void型返回值的Lambda表达式。
使用Action<>表示带参数的void型返回值的Lambda表达式。
使用Func<>表示返回值类型不为空的Lambda表达式(最后一个泛型参数为函数返回值的类型)。
Action<>，Func<>等泛型类型至多接收8个参数。

========


C#的一些特有关键字 >>

internal关键字 >
类和类成员前可以使用[internal]关键字。
internal关键字用在类、接口前表示只能在当前项目中访问该类、接口。
拥有internel关键字的类不能被public类继承。
默认不添加关键字的情况下，类和接口的访问属性即为internal。
internal关键字用在类内成员之前表示只能在当前项目中访问该成员。
在对类内成员使用时，internal关键字可以搭配protected关键字使用，即定义一个只能被当前项目的子类访问的成员。

----

readonly关键字 >
readonly关键字修饰的变量赋值只能在变量定义时或是在该变量所属类的构造函数中。
与const关键字相比，const关键字定义的变量必须在定义时就初始化。
const定义的变量被视为编译时常量，而readonly定义的变量被视为运行时常量。
在C#中const只能修饰值类型以及string类型和值为null的引用类型，被const修饰的变量自动带有static属性，const关键字与static关键字不能共同修饰同一个变量。
readonly没有这些限制，可以修饰任意类型，被readonly修饰的变量也默认不带static属性。